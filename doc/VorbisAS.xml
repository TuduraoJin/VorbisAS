<haxe>
	<class path="Array" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurense of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurense of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Enum" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="D:\Program Files\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="D:\Program Files\HaxeToolkit\haxe\std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<empty public="1" params="T" set="method" line="206" static="1">
			<f a="it">
				<t path="Iterable"><c path="empty.T"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if Iterable `it` does not contain any element.</haxe_doc>
		</empty>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Map" params="K:V" file="D:\Program Files\HaxeToolkit\haxe\std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="D:\Program Files\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta><m n=":deprecated"/></meta>
	</typedef>
	<class path="Math" params="" file="D:\Program Files\HaxeToolkit\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with `NaN` on Windows,
		see [https://bugs.php.net/bug.php?id=42143]</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Std" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/_std/Std.hx">
		<is public="1" set="method" line="26" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="34" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<parseInt public="1" set="method" line="42" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is `null`.</haxe_doc>
		</parseInt>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check `hasNext` first. A call to this
		method while `hasNext` is false yields unspecified behavior.

		On the other hand iterators should not require a call to `hasNext`
		before the first call to `next` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="D:\Program Files\HaxeToolkit\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Type" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/_std/Type.hx">
		<createEmptyInstance public="1" params="T" set="method" line="151" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="D:\Program Files\HaxeToolkit\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned Int type is only defined for Flash and C#.
	Simulate it for other platforms.</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/UInt.hx" private="1" module="UInt"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="flash.events.IEventDispatcher" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useWeakReference:false,priority:0,useCapture:false}</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useCapture:false}</e></m></meta>
		</removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useWeakReference:false,priority:0,useCapture:false}</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useCapture:false}</e></m></meta>
		</removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><x path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<height public="1"><x path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><x path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><x path="Float"/></rotation>
		<rotationX public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotationY public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><x path="Bool"/></visible>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{shapeFlag:false}</e></m></meta>
		</hitTestPoint>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<needsSoftKeyboard public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<requestSoftKeyboard public="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1" expr="{endIndex:2147483647,beginIndex:0}">
			<f a="?beginIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{endIndex:2147483647,beginIndex:0}</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</removeChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<stopAllMovieClips public="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</stopAllMovieClips>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<startDrag public="1" set="method">
			<f a="?lockCenter:?bounds" v="false:">
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{lockCenter:false}</e></m></meta>
		</startDrag>
		<startTouchDrag public="1" expr="{lockCenter:false}">
			<f a="touchPointID:?lockCenter:?bounds">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{lockCenter:false}</e></m>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</startTouchDrag>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<stopTouchDrag public="1">
			<f a="touchPointID">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><x path="Int"/></currentFrame>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><x path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><x path="Int"/></framesLoaded>
		<isPlaying public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><x path="Int"/></totalFrames>
		<trackAsMenu public="1"><x path="Bool"/></trackAsMenu>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" expr="false" line="51" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skip_constructor>
		<enum_to_string public="1" set="method" line="82" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="91" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__instanceof>
		<__clear_trace public="1" set="method" line="101" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="109" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="115" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="143" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="162" static="1">
			<f a="v:str">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__string_rec>
		<__unprotect__ set="method" line="207" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<mapDynamic public="1" set="method" line="211" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</mapDynamic>
		<filterDynamic public="1" set="method" line="219" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</filterDynamic>
		<start set="method" line="53">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</start>
		<doInitDelay set="method" line="73"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<init set="method" line="78"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="flash.Vector" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="47" static="1">
			<f a="v">
				<c path="Array"><c path="ofArray.T"/></c>
				<c path="flash.Vector"><c path="ofArray.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="51" static="1">
			<f a="v">
				<c path="flash.Vector"><c path="convert.T"/></c>
				<c path="flash.Vector"><c path="convert.U"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</convert>
		<length public="1"><x path="Int"/></length>
		<fixed public="1"><x path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="?pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<new public="1" set="method"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10</e></m>
		</meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><x path="UInt"/></errno>
		<stub public="1"><x path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><x path="Bool"/></silent>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT2/>
		<ACTIONSCRIPT3/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.display.BitmapData" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><x path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><x path="Bool"/></transparent>
		<width public="1" set="null"><x path="Int"/></width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<t path="flash.utils.Object"/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::::false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{mergeAlpha:false}</e></m></meta>
		</copyPixels>
		<copyPixelsToByteArray public="1">
			<f a="rect:data">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyPixelsToByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":::::false">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{smoothing:false}</e></m></meta>
		</draw>
		<drawWithQuality public="1" expr="{smoothing:false}">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{smoothing:false}</e></m>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</drawWithQuality>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<t path="flash.utils.Object"/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method">
			<f a="mask:color:?findColor" v="::true">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{findColor:true}</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><x path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<hitTest public="1" set="method">
			<f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold" v="::::1">
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<t path="flash.utils.Object"/>
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{secondAlphaThreshold:1}</e></m></meta>
		</hitTest>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<noise public="1" set="method">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{grayScale:false,channelOptions:7,high:255,low:0}</e></m></meta>
		</noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method">
			<f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets" v="::::::7:false:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="Array"><c path="flash.geom.Point"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{grayScale:false,channelOptions:7}</e></m></meta>
		</perlinNoise>
		<pixelDissolve public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor" v=":::0:0:0">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{fillColor:0,numPixels:0,randomSeed:0}</e></m></meta>
		</pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<threshold public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0:0xFFFFFFFF:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="String"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{copySource:false,mask:0xFFFFFFFF,color:0}</e></m></meta>
		</threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<new public="1" set="method">
			<f a="width:height:?transparent:?fillColor" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{fillColor:0xFFFFFFFF,transparent:true}</e></m></meta>
		</new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/BlendMode.hx">
		<ADD/>
		<ALPHA/>
		<DARKEN/>
		<DIFFERENCE/>
		<ERASE/>
		<HARDLIGHT/>
		<INVERT/>
		<LAYER/>
		<LIGHTEN/>
		<MULTIPLY/>
		<NORMAL/>
		<OVERLAY/>
		<SCREEN/>
		<SHADER/>
		<SUBTRACT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/CapsStyle.hx">
		<NONE/>
		<ROUND/>
		<SQUARE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/ColorCorrection.hx">
		<DEFAULT/>
		<OFF/>
		<ON/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/ColorCorrectionSupport.hx">
		<DEFAULT_OFF/>
		<DEFAULT_ON/>
		<UNSUPPORTED/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<frame public="1" set="null"><x path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/GradientType.hx">
		<LINEAR/>
		<RADIAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{smooth:false,repeat:true}</e></m></meta>
		</beginBitmapFill>
		<beginFill public="1" set="method">
			<f a="color:?alpha" v=":1">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{alpha:1}</e></m></meta>
		</beginFill>
		<beginGradientFill public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<e path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<e path="flash.display.SpreadMethod"/>
				<e path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{focalPointRatio:0}</e></m></meta>
		</beginGradientFill>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<cubicCurveTo public="1">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{smooth:false,repeat:true}</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<e path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<e path="flash.display.SpreadMethod"/>
				<e path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{focalPointRatio:0}</e></m></meta>
		</lineGradientStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineStyle public="1" set="method">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v=":0:1:false::::3">
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="flash.display.LineScaleMode"/>
				<e path="flash.display.CapsStyle"/>
				<e path="flash.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{miterLimit:3,pixelHinting:false,alpha:1,color:0}</e></m></meta>
		</lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<readGraphicsData public="1" expr="{recurse:true}">
			<f a="?recurse">
				<x path="Bool"/>
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
			</f>
			<meta>
				<m n=":value"><e>{recurse:true}</e></m>
				<m n=":require"><e>flash11_6</e></m>
			</meta>
		</readGraphicsData>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/GraphicsPathWinding.hx">
		<EVEN_ODD/>
		<NON_ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/InterpolationMethod.hx">
		<LINEAR_RGB/>
		<RGB/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/JointStyle.hx">
		<BEVEL/>
		<MITER/>
		<ROUND/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/LineScaleMode.hx">
		<HORIZONTAL/>
		<NONE/>
		<NORMAL/>
		<VERTICAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Loader" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<unloadAndStop public="1" set="method">
			<f a="?gc" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{gc:true}</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</unloadAndStop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<childSandboxBridge public="1">
			<d/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</childSandboxBridge>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<height public="1" set="null"><x path="Int"/></height>
		<isURLInaccessible public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<parentSandboxBridge public="1">
			<d/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</parentSandboxBridge>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><x path="UInt"/></swfVersion>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><x path="Int"/></width>
	</class>
	<class path="flash.display.NativeMenu" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.display.Scene" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><x path="Int"/></numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Shader.hx" extern="1">
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/ShaderPrecision.hx">
		<FAST/>
		<FULL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Shape" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/SpreadMethod.hx">
		<PAD/>
		<REFLECT/>
		<REPEAT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Stage" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<allowsFullScreen public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</allowsFullScreen>
		<allowsFullScreenInteractive public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<browserZoomFactor public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</browserZoomFactor>
		<color public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<contentsScaleFactor public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</contentsScaleFactor>
		<displayContextInfo public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><x path="Float"/></frameRate>
		<fullScreenHeight public="1" set="null"><x path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><x path="UInt"/></fullScreenWidth>
		<mouseLock public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><x path="Bool"/></showDefaultContextMenu>
		<softKeyboardRect public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<stage3Ds public="1">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<stageHeight public="1"><x path="Int"/></stageHeight>
		<stageVideos public="1">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageWidth public="1"><x path="Int"/></stageWidth>
		<wmodeGPU public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
	</class>
	<class path="flash.display.Stage3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<visible public="1"><x path="Bool"/></visible>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<e path="flash.display3D.Context3DRenderMode"/>
	<e path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<requestContext3DMatchingProfiles public="1">
			<f a="profiles">
				<c path="flash.Vector"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash12</e></m></meta>
		</requestContext3DMatchingProfiles>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/StageAlign.hx">
		<BOTTOM/>
		<BOTTOM_LEFT/>
		<BOTTOM_RIGHT/>
		<LEFT/>
		<RIGHT/>
		<TOP/>
		<TOP_LEFT/>
		<TOP_RIGHT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/StageDisplayState.hx">
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<NORMAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/StageQuality.hx">
		<BEST/>
		<HIGH/>
		<HIGH_16X16/>
		<HIGH_16X16_LINEAR/>
		<HIGH_8X8/>
		<HIGH_8X8_LINEAR/>
		<LOW/>
		<MEDIUM/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/StageScaleMode.hx">
		<EXACT_FIT/>
		<NO_BORDER/>
		<NO_SCALE/>
		<SHOW_ALL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display/TriangleCulling.hx">
		<NEGATIVE/>
		<NONE/>
		<POSITIVE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<supportsVideoTexture public="1" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</supportsVideoTexture>
		<backBufferHeight public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</backBufferHeight>
		<backBufferWidth public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</backBufferWidth>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<maxBackBufferHeight public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</maxBackBufferHeight>
		<maxBackBufferWidth public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</maxBackBufferWidth>
		<profile public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash12</e></m></meta>
		</profile>
		<clear public="1" set="method">
			<f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask" v="0:0:0:1:1:0:0xFFFFFFFF">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{mask:0xFFFFFFFF,stencil:0,depth:1,alpha:1,blue:0,green:0,red:0}</e></m></meta>
		</clear>
		<configureBackBuffer public="1" set="method">
			<f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution:?wantsBestResolutionOnBrowserZoom" v=":::true:false:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{wantsBestResolutionOnBrowserZoom:false,wantsBestResolution:false,enableDepthAndStencil:true}</e></m></meta>
		</configureBackBuffer>
		<createCubeTexture public="1" set="method">
			<f a="size:format:optimizeForRenderToTexture:?streamingLevels" v=":::0">
				<x path="Int"/>
				<e path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.CubeTexture"/>
			</f>
			<meta><m n=":value"><e>{streamingLevels:0}</e></m></meta>
		</createCubeTexture>
		<createIndexBuffer public="1" set="method"><f a="numIndices:?bufferUsage">
	<x path="Int"/>
	<e path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createRectangleTexture public="1">
			<f a="width:height:format:optimizeForRenderToTexture">
				<x path="Int"/>
				<x path="Int"/>
				<e path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<c path="flash.display3D.textures.RectangleTexture"/>
			</f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</createRectangleTexture>
		<createTexture public="1" set="method">
			<f a="width:height:format:optimizeForRenderToTexture:?streamingLevels" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<e path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.Texture"/>
			</f>
			<meta><m n=":value"><e>{streamingLevels:0}</e></m></meta>
		</createTexture>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex:?bufferUsage">
	<x path="Int"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createVideoTexture public="1">
			<f a=""><c path="flash.display3D.textures.VideoTexture"/></f>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</createVideoTexture>
		<dispose public="1" set="method">
			<f a="?recreate" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{recreate:true}</e></m></meta>
		</dispose>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method">
			<f a="indexBuffer:?firstIndex:?numTriangles" v=":0:-1">
				<c path="flash.display3D.IndexBuffer3D"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{numTriangles:-1,firstIndex:0}</e></m></meta>
		</drawTriangles>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setFillMode public="1">
			<f a="fillMode">
				<e path="flash.display3D.Context3DFillMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash16</e></m></meta>
		</setFillMode>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setProgramConstantsFromByteArray public="1">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgramConstantsFromMatrix public="1" set="method">
			<f a="programType:firstRegister:matrix:?transposedMatrix" v=":::false">
				<e path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.geom.Matrix3D"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{transposedMatrix:false}</e></m></meta>
		</setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method">
			<f a="programType:firstRegister:data:?numRegisters" v=":::-1">
				<e path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{numRegisters:-1}</e></m></meta>
		</setProgramConstantsFromVector>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method">
			<f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector:?colorOutputIndex" v=":false:0:0:0">
				<c path="flash.display3D.textures.TextureBase"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{colorOutputIndex:0,surfaceSelector:0,antiAlias:0,enableDepthAndStencil:false}</e></m></meta>
		</setRenderToTexture>
		<setSamplerStateAt public="1">
			<f a="sampler:wrap:filter:mipfilter">
				<x path="Int"/>
				<e path="flash.display3D.Context3DWrapMode"/>
				<e path="flash.display3D.Context3DTextureFilter"/>
				<e path="flash.display3D.Context3DMipFilter"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_6</e></m></meta>
		</setSamplerStateAt>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method">
			<f a="referenceValue:?readMask:?writeMask" v=":255:255">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{writeMask:255,readMask:255}</e></m></meta>
		</setStencilReferenceValue>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setVertexBufferAt public="1" set="method">
			<f a="index:buffer:?bufferOffset:?format" v="::0:">
				<x path="Int"/>
				<c path="flash.display3D.VertexBuffer3D"/>
				<x path="Int"/>
				<e path="flash.display3D.Context3DVertexBufferFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{bufferOffset:0}</e></m></meta>
		</setVertexBufferAt>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DBlendFactor.hx">
		<DESTINATION_ALPHA/>
		<DESTINATION_COLOR/>
		<ONE/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<SOURCE_COLOR/>
		<ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DBufferUsage" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DBufferUsage.hx">
		<DYNAMIC_DRAW/>
		<STATIC_DRAW/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash12</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DCompareMode.hx">
		<ALWAYS/>
		<EQUAL/>
		<GREATER/>
		<GREATER_EQUAL/>
		<LESS/>
		<LESS_EQUAL/>
		<NEVER/>
		<NOT_EQUAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DFillMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DFillMode.hx">
		<SOLID/>
		<WIREFRAME/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash16</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DMipFilter" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DMipFilter.hx">
		<MIPLINEAR/>
		<MIPNEAREST/>
		<MIPNONE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DProfile" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DProfile.hx">
		<BASELINE/>
		<BASELINE_CONSTRAINED/>
		<BASELINE_EXTENDED/>
		<STANDARD/>
		<STANDARD_CONSTRAINED/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DProgramType.hx">
		<FRAGMENT/>
		<VERTEX/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DRenderMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DRenderMode.hx">
		<AUTO/>
		<SOFTWARE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DStencilAction.hx">
		<DECREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<INCREMENT_WRAP/>
		<INVERT/>
		<KEEP/>
		<SET/>
		<ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFilter" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFilter.hx">
		<ANISOTROPIC16X/>
		<ANISOTROPIC2X/>
		<ANISOTROPIC4X/>
		<ANISOTROPIC8X/>
		<LINEAR/>
		<NEAREST/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFormat.hx">
		<BGRA/>
		<BGRA_PACKED/>
		<BGR_PACKED/>
		<COMPRESSED/>
		<COMPRESSED_ALPHA/>
		<RGBA_HALF_FLOAT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DTriangleFace.hx">
		<BACK/>
		<FRONT/>
		<FRONT_AND_BACK/>
		<NONE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DVertexBufferFormat.hx">
		<BYTES_4/>
		<FLOAT_1/>
		<FLOAT_2/>
		<FLOAT_3/>
		<FLOAT_4/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DWrapMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Context3DWrapMode.hx">
		<CLAMP/>
		<CLAMP_U_REPEAT_V/>
		<REPEAT/>
		<REPEAT_U_CLAMP_V/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/Program3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{async:false}</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:side:?miplevel" v="::0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{miplevel:0}</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:side:?miplevel" v=":::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{miplevel:0}</e></m></meta>
		</uploadFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.RectangleTexture" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/textures/RectangleTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromBitmapData public="1" set="method"><f a="source">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{async:false}</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:?miplevel" v=":0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{miplevel:0}</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?miplevel" v="::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{miplevel:0}</e></m></meta>
		</uploadFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.VideoTexture" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/display3D/textures/VideoTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<attachCamera public="1" set="method"><f a="theCamera">
	<c path="flash.media.Camera"/>
	<x path="Void"/>
</f></attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1" set="method">
			<f a="?message:?id" v=":0">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{id:0}</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.errors.ArgumentError" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/errors/ArgumentError.hx" extern="1">
		<extends path="flash.errors.Error"/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"ArgumentError"</e></m>
		</meta>
	</class>
	<class path="flash.events.Event" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<BROWSER_ZOOM_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash15</e></m></meta>
		</BROWSER_ZOOM_CHANGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE public="1" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE public="1" static="1"><c path="String"/></CHANNEL_STATE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME public="1" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE public="1" static="1"><c path="String"/></WORKER_STATE>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{cancelable:false,bubbles:false}</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.TextEvent" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text" v=":false:false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{cancelable:false,bubbles:false}</e></m></meta>
		</new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<errorID public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</errorID>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false::0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{id:0,cancelable:false,bubbles:false}</e></m></meta>
		</new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/EventPhase.hx">
		<AT_TARGET/>
		<BUBBLING_PHASE/>
		<CAPTURING_PHASE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.events.IOErrorEvent" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false::0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{id:0,cancelable:false,bubbles:false}</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/ProgressEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROGRESS public="1" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" static="1"><c path="String"/></SOCKET_DATA>
		<bytesLoaded public="1"><x path="Float"/></bytesLoaded>
		<bytesTotal public="1"><x path="Float"/></bytesTotal>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal" v=":false:false:0:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{bytesTotal:0,bytesLoaded:0,cancelable:false,bubbles:false}</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.SampleDataEvent" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/SampleDataEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<SAMPLE_DATA public="1" static="1"><c path="String"/></SAMPLE_DATA>
		<data public="1"><c path="flash.utils.ByteArray"/></data>
		<position public="1"><x path="Float"/></position>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?theposition:?thedata" v=":false:false:0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{theposition:0,cancelable:false,bubbles:false}</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><x path="Bool"/></available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1"><x path="UInt"/></color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1:1:1:1:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{alphaOffset:0,blueOffset:0,greenOffset:0,redOffset:0,alphaMultiplier:1,blueMultiplier:1,greenMultiplier:1,redMultiplier:1}</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Matrix" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<createBox public="1" set="method">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ty:0,tx:0,rotation:0}</e></m></meta>
		</createBox>
		<createGradientBox public="1" set="method">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ty:0,tx:0,rotation:0}</e></m></meta>
		</createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setTo public="1">
			<f a="aa:ba:ca:da:txa:tya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ty:0,tx:0,d:1,c:0,b:0,a:1}</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" set="null"><x path="Float"/></determinant>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<rawData public="1"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRawDataFrom public="1" expr="{transpose:false,index:0}">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{transpose:false,index:0}</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataFrom>
		<copyRawDataTo public="1" expr="{transpose:false,index:0}">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{transpose:false,index:0}</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyToMatrix3D public="1">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/Orientation3D.hx">
		<AXIS_ANGLE/>
		<EULER_ANGLES/>
		<QUATERNION/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1"><x path="Float"/></fieldOfView>
		<focalLength public="1"><x path="Float"/></focalLength>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<copyFrom public="1">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{y:0,x:0}</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/Rectangle.hx" extern="1">
		<bottom public="1"><x path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1"><x path="Float"/></left>
		<right public="1"><x path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><x path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{height:0,width:0,y:0,x:0}</e></m></meta>
		</new>
	</class>
	<class path="flash.geom.Transform" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<length public="1" set="null"><x path="Float"/></length>
		<lengthSquared public="1" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<copyFrom public="1">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" set="method">
			<f a="toCompare:?allFour" v=":false">
				<c path="flash.geom.Vector3D"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{allFour:false}</e></m></meta>
		</equals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="flash.geom.Vector3D"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{allFour:false}</e></m></meta>
		</nearEquals>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y:?z:?w" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{w:0,z:0,y:0,x:0}</e></m></meta>
		</new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.AVCaptionStyle" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/AVCaptionStyle.hx" extern="1">
		<BLACK public="1" static="1"><c path="String"/></BLACK>
		<BLUE public="1" static="1"><c path="String"/></BLUE>
		<BRIGHT_BLUE public="1" static="1"><c path="String"/></BRIGHT_BLUE>
		<BRIGHT_CYAN public="1" static="1"><c path="String"/></BRIGHT_CYAN>
		<BRIGHT_GREEN public="1" static="1"><c path="String"/></BRIGHT_GREEN>
		<BRIGHT_MAGENTA public="1" static="1"><c path="String"/></BRIGHT_MAGENTA>
		<BRIGHT_RED public="1" static="1"><c path="String"/></BRIGHT_RED>
		<BRIGHT_WHITE public="1" static="1"><c path="String"/></BRIGHT_WHITE>
		<BRIGHT_YELLOW public="1" static="1"><c path="String"/></BRIGHT_YELLOW>
		<CASUAL public="1" static="1"><c path="String"/></CASUAL>
		<CURSIVE public="1" static="1"><c path="String"/></CURSIVE>
		<CYAN public="1" static="1"><c path="String"/></CYAN>
		<DARK_BLUE public="1" static="1"><c path="String"/></DARK_BLUE>
		<DARK_CYAN public="1" static="1"><c path="String"/></DARK_CYAN>
		<DARK_GREEN public="1" static="1"><c path="String"/></DARK_GREEN>
		<DARK_MAGENTA public="1" static="1"><c path="String"/></DARK_MAGENTA>
		<DARK_RED public="1" static="1"><c path="String"/></DARK_RED>
		<DARK_YELLOW public="1" static="1"><c path="String"/></DARK_YELLOW>
		<DEFAULT public="1" static="1"><c path="String"/></DEFAULT>
		<DEPRESSED public="1" static="1"><c path="String"/></DEPRESSED>
		<GRAY public="1" static="1"><c path="String"/></GRAY>
		<GREEN public="1" static="1"><c path="String"/></GREEN>
		<LARGE public="1" static="1"><c path="String"/></LARGE>
		<LEFT_DROP_SHADOW public="1" static="1"><c path="String"/></LEFT_DROP_SHADOW>
		<MAGENTA public="1" static="1"><c path="String"/></MAGENTA>
		<MEDIUM public="1" static="1"><c path="String"/></MEDIUM>
		<MONOSPACED_WITHOUT_SERIFS public="1" static="1"><c path="String"/></MONOSPACED_WITHOUT_SERIFS>
		<MONOSPACE_WITH_SERIFS public="1" static="1"><c path="String"/></MONOSPACE_WITH_SERIFS>
		<NONE public="1" static="1"><c path="String"/></NONE>
		<PROPORTIONAL_WITHOUT_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITHOUT_SERIFS>
		<PROPORTIONAL_WITH_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITH_SERIFS>
		<RAISED public="1" static="1"><c path="String"/></RAISED>
		<RED public="1" static="1"><c path="String"/></RED>
		<RIGHT_DROP_SHADOW public="1" static="1"><c path="String"/></RIGHT_DROP_SHADOW>
		<SMALL public="1" static="1"><c path="String"/></SMALL>
		<SMALL_CAPITALS public="1" static="1"><c path="String"/></SMALL_CAPITALS>
		<UNIFORM public="1" static="1"><c path="String"/></UNIFORM>
		<WHITE public="1" static="1"><c path="String"/></WHITE>
		<YELLOW public="1" static="1"><c path="String"/></YELLOW>
		<backgroundColor public="1"><c path="String"/></backgroundColor>
		<backgroundOpacity public="1"><c path="String"/></backgroundOpacity>
		<bottomInset public="1"><c path="String"/></bottomInset>
		<edgeColor public="1"><c path="String"/></edgeColor>
		<fillColor public="1"><c path="String"/></fillColor>
		<fillOpacity public="1"><c path="String"/></fillOpacity>
		<font public="1"><c path="String"/></font>
		<fontColor public="1"><c path="String"/></fontColor>
		<fontEdge public="1"><c path="String"/></fontEdge>
		<fontOpacity public="1"><c path="String"/></fontOpacity>
		<size public="1"><c path="String"/></size>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVPlayState" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/AVPlayState.hx" extern="1">
		<BUFFERING public="1" static="1"><x path="Int"/></BUFFERING>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<PAUSED public="1" static="1"><x path="Int"/></PAUSED>
		<PLAYING public="1" static="1"><x path="Int"/></PLAYING>
		<READY public="1" static="1"><x path="Int"/></READY>
		<SUSPENDED public="1" static="1"><x path="Int"/></SUSPENDED>
		<TRICK_PLAY public="1" static="1"><x path="Int"/></TRICK_PLAY>
		<UNINITIALIZED public="1" static="1"><x path="Int"/></UNINITIALIZED>
		<UNRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></UNRECOVERABLE_ERROR>
		<state public="1" set="null"><x path="Int"/></state>
		<new public="1" set="method"><f a="state">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVResult" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/AVResult.hx" extern="1">
		<ASYNC_OPERATION_IN_PROGRESS public="1" static="1"><x path="Int"/></ASYNC_OPERATION_IN_PROGRESS>
		<AUDIO_ONLY_STREAM_END public="1" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_END>
		<AUDIO_ONLY_STREAM_START public="1" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_START>
		<AUDIO_START_ERROR public="1" static="1"><x path="Int"/></AUDIO_START_ERROR>
		<BAD_MANIFEST_SIGNATURE public="1" static="1"><x path="Int"/></BAD_MANIFEST_SIGNATURE>
		<BAD_MEDIASAMPLE_FOUND public="1" static="1"><x path="Int"/></BAD_MEDIASAMPLE_FOUND>
		<BAD_MEDIA_INTERLEAVING public="1" static="1"><x path="Int"/></BAD_MEDIA_INTERLEAVING>
		<CALLED_FROM_WRONG_THREAD public="1" static="1"><x path="Int"/></CALLED_FROM_WRONG_THREAD>
		<CANNOT_ERASE_TIMELINE public="1" static="1"><x path="Int"/></CANNOT_ERASE_TIMELINE>
		<CANNOT_FAIL_OVER public="1" static="1"><x path="Int"/></CANNOT_FAIL_OVER>
		<CANNOT_HANDLE_MAIN_MANIFEST_UPDATE public="1" static="1"><x path="Int"/></CANNOT_HANDLE_MAIN_MANIFEST_UPDATE>
		<CANNOT_LOAD_PLAY_LIST public="1" static="1"><x path="Int"/></CANNOT_LOAD_PLAY_LIST>
		<CANNOT_SPLIT_TIMELINE public="1" static="1"><x path="Int"/></CANNOT_SPLIT_TIMELINE>
		<CODEC_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CODEC_NOT_SUPPORTED>
		<COMPONENT_CREATION_FAILURE public="1" static="1"><x path="Int"/></COMPONENT_CREATION_FAILURE>
		<CONTAINER_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CONTAINER_NOT_SUPPORTED>
		<CONTENT_LENGTH_MISMATCH public="1" static="1"><x path="Int"/></CONTENT_LENGTH_MISMATCH>
		<CRYPTO_ALGORITHM_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CRYPTO_ALGORITHM_NOT_SUPPORTED>
		<CRYPTO_ERROR_BAD_CERTIFICATE public="1" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_CERTIFICATE>
		<CRYPTO_ERROR_BAD_PARAMETER public="1" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_PARAMETER>
		<CRYPTO_ERROR_BUFFER_TOO_SMALL public="1" static="1"><x path="Int"/></CRYPTO_ERROR_BUFFER_TOO_SMALL>
		<CRYPTO_ERROR_CORRUPTED_DATA public="1" static="1"><x path="Int"/></CRYPTO_ERROR_CORRUPTED_DATA>
		<CRYPTO_ERROR_DIGEST_FINISH public="1" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_FINISH>
		<CRYPTO_ERROR_DIGEST_UPDATE public="1" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_UPDATE>
		<CRYPTO_ERROR_UNKNOWN public="1" static="1"><x path="Int"/></CRYPTO_ERROR_UNKNOWN>
		<CURRENT_PERIOD_EXPIRED public="1" static="1"><x path="Int"/></CURRENT_PERIOD_EXPIRED>
		<DECODER_FAILED public="1" static="1"><x path="Int"/></DECODER_FAILED>
		<DEVICE_OPEN_ERROR public="1" static="1"><x path="Int"/></DEVICE_OPEN_ERROR>
		<DID_NOT_GET_NEXT_FRAGMENT public="1" static="1"><x path="Int"/></DID_NOT_GET_NEXT_FRAGMENT>
		<DRM_INIT_ERROR public="1" static="1"><x path="Int"/></DRM_INIT_ERROR>
		<DRM_NOT_AVAILABLE public="1" static="1"><x path="Int"/></DRM_NOT_AVAILABLE>
		<END_OF_PERIOD public="1" static="1"><x path="Int"/></END_OF_PERIOD>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<FILE_NOT_FOUND public="1" static="1"><x path="Int"/></FILE_NOT_FOUND>
		<FILE_OPEN_ERROR public="1" static="1"><x path="Int"/></FILE_OPEN_ERROR>
		<FILE_READ_ERROR public="1" static="1"><x path="Int"/></FILE_READ_ERROR>
		<FILE_STRUCTURE_INVALID public="1" static="1"><x path="Int"/></FILE_STRUCTURE_INVALID>
		<FILE_WRITE_ERROR public="1" static="1"><x path="Int"/></FILE_WRITE_ERROR>
		<FRAGMENT_READ_ERROR public="1" static="1"><x path="Int"/></FRAGMENT_READ_ERROR>
		<GENERIC_ERROR public="1" static="1"><x path="Int"/></GENERIC_ERROR>
		<HTTP_TIME_OUT public="1" static="1"><x path="Int"/></HTTP_TIME_OUT>
		<ID3_PARSE_ERROR public="1" static="1"><x path="Int"/></ID3_PARSE_ERROR>
		<INCOMPATIBLE_RENDER_MODE public="1" static="1"><x path="Int"/></INCOMPATIBLE_RENDER_MODE>
		<INCOMPATIBLE_VERSION public="1" static="1"><x path="Int"/></INCOMPATIBLE_VERSION>
		<INTERNAL_ERROR public="1" static="1"><x path="Int"/></INTERNAL_ERROR>
		<INVALID_KEY public="1" static="1"><x path="Int"/></INVALID_KEY>
		<INVALID_OPERATION public="1" static="1"><x path="Int"/></INVALID_OPERATION>
		<INVALID_PARAMETER public="1" static="1"><x path="Int"/></INVALID_PARAMETER>
		<INVALID_REPLACE_DURATION public="1" static="1"><x path="Int"/></INVALID_REPLACE_DURATION>
		<INVALID_SEEK_TIME public="1" static="1"><x path="Int"/></INVALID_SEEK_TIME>
		<INVALID_WITH_AUDIO_ONLY_FILE public="1" static="1"><x path="Int"/></INVALID_WITH_AUDIO_ONLY_FILE>
		<IRRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></IRRECOVERABLE_ERROR>
		<KEY_NOT_FOUND public="1" static="1"><x path="Int"/></KEY_NOT_FOUND>
		<KEY_SERVER_NOT_FOUND public="1" static="1"><x path="Int"/></KEY_SERVER_NOT_FOUND>
		<LISTENER_NOT_FOUND public="1" static="1"><x path="Int"/></LISTENER_NOT_FOUND>
		<LIVE_HOLD public="1" static="1"><x path="Int"/></LIVE_HOLD>
		<LIVE_WINDOW_MOVED_BACKWARD public="1" static="1"><x path="Int"/></LIVE_WINDOW_MOVED_BACKWARD>
		<LOST_CONNECTION_RECOVERABLE public="1" static="1"><x path="Int"/></LOST_CONNECTION_RECOVERABLE>
		<MANIFEST_FILE_UNEXPECTEDLY_CHANGED public="1" static="1"><x path="Int"/></MANIFEST_FILE_UNEXPECTEDLY_CHANGED>
		<NETWORK_DOWN public="1" static="1"><x path="Int"/></NETWORK_DOWN>
		<NETWORK_ERROR public="1" static="1"><x path="Int"/></NETWORK_ERROR>
		<NETWORK_UNAVAILABLE public="1" static="1"><x path="Int"/></NETWORK_UNAVAILABLE>
		<NOT_IMPLEMENTED public="1" static="1"><x path="Int"/></NOT_IMPLEMENTED>
		<NO_AUDIO_SINK public="1" static="1"><x path="Int"/></NO_AUDIO_SINK>
		<NO_FIXED_SIZE public="1" static="1"><x path="Int"/></NO_FIXED_SIZE>
		<NO_TIMELINE public="1" static="1"><x path="Int"/></NO_TIMELINE>
		<NO_USEABLE_BITRATE_PROFILE public="1" static="1"><x path="Int"/></NO_USEABLE_BITRATE_PROFILE>
		<NULL_OPERATION public="1" static="1"><x path="Int"/></NULL_OPERATION>
		<ONLY_ALLOWED_IN_PAUSED_STATE public="1" static="1"><x path="Int"/></ONLY_ALLOWED_IN_PAUSED_STATE>
		<OPERATION_ABORTED public="1" static="1"><x path="Int"/></OPERATION_ABORTED>
		<OUT_OF_MEMORY public="1" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<OVERFLOW public="1" static="1"><x path="Int"/></OVERFLOW>
		<PARSE_ERROR public="1" static="1"><x path="Int"/></PARSE_ERROR>
		<PARTIAL_REPLACEMENT public="1" static="1"><x path="Int"/></PARTIAL_REPLACEMENT>
		<PERIOD_HOLD public="1" static="1"><x path="Int"/></PERIOD_HOLD>
		<PERIOD_NOT_LOADED public="1" static="1"><x path="Int"/></PERIOD_NOT_LOADED>
		<PLAYBACK_NOT_ENABLED public="1" static="1"><x path="Int"/></PLAYBACK_NOT_ENABLED>
		<POSTROLL_WITH_LIVE_NOT_ALLOWED public="1" static="1"><x path="Int"/></POSTROLL_WITH_LIVE_NOT_ALLOWED>
		<PREVIOUS_STEP_SEEK_IN_PROGRESS public="1" static="1"><x path="Int"/></PREVIOUS_STEP_SEEK_IN_PROGRESS>
		<PROTOCOL_NOT_SUPPORTED public="1" static="1"><x path="Int"/></PROTOCOL_NOT_SUPPORTED>
		<RANGE_ERROR public="1" static="1"><x path="Int"/></RANGE_ERROR>
		<RANGE_SPANS_READHEAD public="1" static="1"><x path="Int"/></RANGE_SPANS_READHEAD>
		<RENDITION_M3U8_ERROR public="1" static="1"><x path="Int"/></RENDITION_M3U8_ERROR>
		<REPLACEMENT_FAILED public="1" static="1"><x path="Int"/></REPLACEMENT_FAILED>
		<RESOURCE_NOT_SPECIFIED public="1" static="1"><x path="Int"/></RESOURCE_NOT_SPECIFIED>
		<SECURITY_ERROR public="1" static="1"><x path="Int"/></SECURITY_ERROR>
		<SEEK_FAILED public="1" static="1"><x path="Int"/></SEEK_FAILED>
		<SEGMENT_SKIPPED_ON_FAILURE public="1" static="1"><x path="Int"/></SEGMENT_SKIPPED_ON_FAILURE>
		<SIZE_UNKNOWN public="1" static="1"><x path="Int"/></SIZE_UNKNOWN>
		<SPS_PPS_FOUND_OUTSIDE_AVCC public="1" static="1"><x path="Int"/></SPS_PPS_FOUND_OUTSIDE_AVCC>
		<SUCCESS public="1" static="1"><x path="Int"/></SUCCESS>
		<SWITCH_TO_ASYMMETRIC_PROFILE public="1" static="1"><x path="Int"/></SWITCH_TO_ASYMMETRIC_PROFILE>
		<TIMELINE_TOO_SHORT public="1" static="1"><x path="Int"/></TIMELINE_TOO_SHORT>
		<UNDERFLOW public="1" static="1"><x path="Int"/></UNDERFLOW>
		<UNSUPPORTED_CONFIGURATION public="1" static="1"><x path="Int"/></UNSUPPORTED_CONFIGURATION>
		<UNSUPPORTED_HLS_VERSION public="1" static="1"><x path="Int"/></UNSUPPORTED_HLS_VERSION>
		<UNSUPPORTED_OPERATION public="1" static="1"><x path="Int"/></UNSUPPORTED_OPERATION>
		<VIDEO_PROFILE_NOT_SUPPORTED public="1" static="1"><x path="Int"/></VIDEO_PROFILE_NOT_SUPPORTED>
		<WAITING_FOR_INIT public="1" static="1"><x path="Int"/></WAITING_FOR_INIT>
		<result public="1" set="null"><x path="Int"/></result>
		<new public="1" set="method"><f a="inResult">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVSource" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/AVSource.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVStream" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/AVStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<HARDWARE public="1" static="1"><c path="String"/></HARDWARE>
		<SOFTWARE public="1" static="1"><c path="String"/></SOFTWARE>
		<UNDEFINED public="1" static="1"><c path="String"/></UNDEFINED>
		<backBufferLength public="1" set="null"><x path="Float"/></backBufferLength>
		<backBufferTime public="1" get="null"><x path="Float"/></backBufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<bufferTime public="1" get="null"><x path="Float"/></bufferTime>
		<captionStyle public="1" get="null"><c path="flash.media.AVCaptionStyle"/></captionStyle>
		<captionsEnabled public="1"><x path="Bool"/></captionsEnabled>
		<clientLivePoint public="1" set="null"><x path="Float"/></clientLivePoint>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<decoderType public="1" set="null"><c path="String"/></decoderType>
		<droppedFrames public="1" set="null"><x path="Int"/></droppedFrames>
		<frameTime public="1" set="null"><x path="Float"/></frameTime>
		<initialBufferTime public="1" get="null"><x path="Float"/></initialBufferTime>
		<playState public="1" set="null"><c path="flash.media.AVPlayState"/></playState>
		<renderType public="1" set="null"><c path="String"/></renderType>
		<time public="1" set="null"><x path="Float"/></time>
		<useHardwareDecoder public="1"><x path="Bool"/></useHardwareDecoder>
		<volume public="1"><x path="Float"/></volume>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<fastForward public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></fastForward>
		<pause public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></pause>
		<play public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></play>
		<resume public="1" set="method"><f a=""><x path="Bool"/></f></resume>
		<rewind public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></rewind>
		<seek public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{inBufferSeek:true}</e></m></meta>
		</seek>
		<seekToKeyFrame public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{inBufferSeek:true}</e></m></meta>
		</seekToKeyFrame>
		<seekToLivePoint public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></seekToLivePoint>
		<seekToLocalTime public="1" set="method"><f a="periodIndex:time">
	<x path="Int"/>
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></seekToLocalTime>
		<setPlaySpeed public="1" set="method"><f a="speed:reserved">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPlaySpeed>
		<step public="1" set="method"><f a="frames">
	<x path="Int"/>
	<c path="flash.media.AVResult"/>
</f></step>
		<new public="1" set="method"><f a="source">
	<c path="flash.media.AVSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<fps public="1" set="null"><x path="Float"/></fps>
		<height public="1" set="null"><x path="Int"/></height>
		<index public="1" set="null"><x path="Int"/></index>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<loopback public="1" set="null"><x path="Bool"/></loopback>
		<motionLevel public="1" set="null"><x path="Int"/></motionLevel>
		<motionTimeout public="1" set="null"><x path="Int"/></motionTimeout>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<position public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<quality public="1" set="null"><x path="Int"/></quality>
		<width public="1" set="null"><x path="Int"/></width>
		<copyToByteArray public="1">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToByteArray>
		<copyToVector public="1">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToVector>
		<drawToBitmapData public="1">
			<f a="destination">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</drawToBitmapData>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method">
			<f a="?compress" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{compress:false}</e></m></meta>
		</setLoopback>
		<setMode public="1" set="method">
			<f a="width:height:fps:?favorArea" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{favorArea:true}</e></m></meta>
		</setMode>
		<setMotionLevel public="1" set="method">
			<f a="motionLevel:?timeout" v=":2000">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{timeout:2000}</e></m></meta>
		</setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/ID3Info.hx" extern="1">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" expr="{index:-1}" static="1">
			<f a="?index">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta>
				<m n=":value"><e>{index:-1}</e></m>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":value"><e>{index:-1}</e></m></meta>
		</getMicrophone>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<enableVAD public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<encodeQuality public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<framesPerPacket public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<gain public="1"><x path="Float"/></gain>
		<index public="1" set="null"><x path="Int"/></index>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<noiseSuppressionLevel public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<rate public="1"><x path="Int"/></rate>
		<silenceLevel public="1" set="null"><x path="Float"/></silenceLevel>
		<silenceTimeout public="1" set="null"><x path="Int"/></silenceTimeout>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useEchoSuppression public="1" set="null"><x path="Bool"/></useEchoSuppression>
		<setLoopBack public="1" set="method">
			<f a="?state" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{state:true}</e></m></meta>
		</setLoopBack>
		<setSilenceLevel public="1" set="method">
			<f a="silenceLevel:?timeout" v=":-1">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{timeout:-1}</e></m></meta>
		</setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedMode.hx">
		<FULL_DUPLEX/>
		<HALF_DUPLEX/>
		<HEADSET/>
		<OFF/>
		<SPEAKER_MUTE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<autoGain public="1"><x path="Bool"/></autoGain>
		<echoPath public="1"><x path="Int"/></echoPath>
		<isVoiceDetected public="1"><x path="Int"/></isVoiceDetected>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<nonLinearProcessing public="1"><x path="Bool"/></nonLinearProcessing>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.media.Sound" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<isBuffering public="1" set="null"><x path="Bool"/></isBuffering>
		<isURLInaccessible public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<length public="1" set="null"><x path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<extract public="1" set="method">
			<f a="target:length:?startPosition" v="::-1">
				<c path="flash.utils.ByteArray"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":value"><e>{startPosition:-1}</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</extract>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" expr="{sampleRate:44100,stereo:true}">
			<f a="bytes:samples:?format:?stereo:?sampleRate">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{sampleRate:44100,stereo:true}</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</loadPCMFromByteArray>
		<play public="1" set="method">
			<f a="?startTime:?loops:?sndTransform" v="0:0:">
				<x path="Float"/>
				<x path="Int"/>
				<c path="flash.media.SoundTransform"/>
				<c path="flash.media.SoundChannel"/>
			</f>
			<meta><m n=":value"><e>{loops:0,startTime:0}</e></m></meta>
		</play>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.media.SoundChannel" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<leftPeak public="1" set="null"><x path="Float"/></leftPeak>
		<position public="1" set="null"><x path="Float"/></position>
		<rightPeak public="1" set="null"><x path="Float"/></rightPeak>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/SoundCodec.hx">
		<NELLYMOSER/>
		<PCMA/>
		<PCMU/>
		<SPEEX/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/SoundLoaderContext.hx" extern="1">
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<new public="1" set="method">
			<f a="?bufferTime:?checkPolicyFile" v="1000:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{checkPolicyFile:false,bufferTime:1000}</e></m></meta>
		</new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<pan public="1"><x path="Float"/></pan>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<volume public="1"><x path="Float"/></volume>
		<new public="1" set="method">
			<f a="?vol:?panning" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{panning:0,vol:1}</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<depth public="1"><x path="Int"/></depth>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<attachAVStream public="1">
			<f a="avStream">
				<c path="flash.media.AVStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_7</e></m></meta>
		</attachAVStream>
		<attachCamera public="1">
			<f a="theCamera">
				<c path="flash.media.Camera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/media/VideoStreamSettings.hx" extern="1">
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<codec public="1" set="null"><c path="String"/></codec>
		<fps public="1" set="null"><x path="Float"/></fps>
		<height public="1" set="null"><x path="Int"/></height>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<quality public="1" set="null"><x path="Int"/></quality>
		<width public="1" set="null"><x path="Int"/></width>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<client public="1"><d/></client>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<maxPeerConnections public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<proxyType public="1"><c path="String"/></proxyType>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<uri public="1" set="null"><c path="String"/></uri>
		<usingTLS public="1" set="null"><x path="Bool"/></usingTLS>
		<addHeader public="1" set="method">
			<f a="operation:?mustUnderstand:?param" v=":false:">
				<c path="String"/>
				<x path="Bool"/>
				<t path="flash.utils.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{mustUnderstand:false}</e></m></meta>
		</addHeader>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></connect>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<resetDRMVouchers public="1" set="method" static="1"><f a=""><x path="Void"/></f></resetDRMVouchers>
		<audioCodec public="1" set="null"><x path="UInt"/></audioCodec>
		<audioReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<backBufferLength public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<backBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<bufferTimeMax public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<client public="1"><d/></client>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<dataReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<decodedFrames public="1" set="null"><x path="UInt"/></decodedFrames>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<inBufferSeek public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<liveDelay public="1" set="null"><x path="Float"/></liveDelay>
		<maxPauseBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<multicastAvailabilitySendToAll public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<multicastAvailabilityUpdatePeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastFetchPeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastInfo public="1">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastPushNeighborLimit public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastRelayMarginDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastWindowDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<objectEncoding public="1" set="null"><x path="UInt"/></objectEncoding>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<time public="1" set="null"><x path="Float"/></time>
		<useHardwareDecoder public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<useJitterBuffer public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<videoCodec public="1" set="null"><x path="UInt"/></videoCodec>
		<videoReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<appendBytes public="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<appendBytesAction public="1">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<attach public="1">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method">
			<f a="theCamera:?snapshotMilliseconds" v=":-1">
				<c path="flash.media.Camera"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{snapshotMilliseconds:-1}</e></m></meta>
		</attachCamera>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<dispose public="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></play>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></send>
		<step public="1">
			<f a="frames">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/NetStreamInfo.hx" extern="1">
		<SRTT public="1" set="null"><x path="Float"/></SRTT>
		<audioBufferByteLength public="1" set="null"><x path="Float"/></audioBufferByteLength>
		<audioBufferLength public="1" set="null"><x path="Float"/></audioBufferLength>
		<audioByteCount public="1" set="null"><x path="Float"/></audioByteCount>
		<audioBytesPerSecond public="1" set="null"><x path="Float"/></audioBytesPerSecond>
		<audioLossRate public="1" set="null"><x path="Float"/></audioLossRate>
		<byteCount public="1" set="null"><x path="Float"/></byteCount>
		<currentBytesPerSecond public="1" set="null"><x path="Float"/></currentBytesPerSecond>
		<dataBufferByteLength public="1" set="null"><x path="Float"/></dataBufferByteLength>
		<dataBufferLength public="1" set="null"><x path="Float"/></dataBufferLength>
		<dataByteCount public="1" set="null"><x path="Float"/></dataByteCount>
		<dataBytesPerSecond public="1" set="null"><x path="Float"/></dataBytesPerSecond>
		<droppedFrames public="1" set="null"><x path="Float"/></droppedFrames>
		<isLive public="1" set="null"><x path="Bool"/></isLive>
		<maxBytesPerSecond public="1" set="null"><x path="Float"/></maxBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<playbackBytesPerSecond public="1" set="null"><x path="Float"/></playbackBytesPerSecond>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<uri public="1" set="null"><c path="String"/></uri>
		<videoBufferByteLength public="1" set="null"><x path="Float"/></videoBufferByteLength>
		<videoBufferLength public="1" set="null"><x path="Float"/></videoBufferLength>
		<videoByteCount public="1" set="null"><x path="Float"/></videoByteCount>
		<videoBytesPerSecond public="1" set="null"><x path="Float"/></videoBytesPerSecond>
		<videoLossRate public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<xmpData public="1" set="null"><d/></xmpData>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive" v="::::::::::::::::::::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{isLive:true}</e></m></meta>
		</new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<bytesPushedFromPeers public="1" set="null"><x path="Float"/></bytesPushedFromPeers>
		<bytesPushedToPeers public="1" set="null"><x path="Float"/></bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" set="null"><x path="Float"/></bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" set="null"><x path="Float"/></bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" set="null"><x path="Float"/></bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" set="null"><x path="Float"/></bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" set="null"><x path="Float"/></fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" set="null"><x path="Float"/></fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><x path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" set="null"><x path="Float"/></fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" set="null"><x path="Float"/></fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" set="null"><x path="Float"/></fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" set="null"><x path="Float"/></receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" set="null"><x path="Float"/></receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" set="null"><x path="Float"/></sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><x path="Float"/></sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" set="null"><x path="Float"/></sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><x path="Float"/></len>
		<offset public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><x path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><c path="String"/></transition>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1"><c path="String"/></digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<useRedirectedURL public="1" set="method">
			<f a="sourceRequest:?wholeURL:?pattern:?replace" v=":false::">
				<c path="flash.net.URLRequest"/>
				<x path="Bool"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{wholeURL:false}</e></m></meta>
		</useRedirectedURL>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.IDataInput" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{length:0,offset:0}</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="flash.net.URLStream" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/net/URLStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.utils.IDataInput"/>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<diskCacheEnabled public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</diskCacheEnabled>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</length>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<position public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</position>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method"><f a="request">
	<c path="flash.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{length:0,offset:0}</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<stop public="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/system/ImageDecodingPolicy.hx">
		<ON_DEMAND/>
		<ON_LOAD/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/system/LoaderContext.hx" extern="1">
		<allowCodeImport public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<allowLoadBytesCodeExecution public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method">
			<f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false::">
				<x path="Bool"/>
				<c path="flash.system.ApplicationDomain"/>
				<c path="flash.system.SecurityDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{checkPolicyFile:false}</e></m></meta>
		</new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/AntiAliasType.hx">
		<ADVANCED/>
		<NORMAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<t path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<alwaysShowSelection public="1"><x path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><x path="Bool"/></background>
		<backgroundColor public="1"><x path="UInt"/></backgroundColor>
		<border public="1"><x path="Bool"/></border>
		<borderColor public="1"><x path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><x path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><x path="Int"/></caretIndex>
		<condenseWhite public="1"><x path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><x path="Int"/></length>
		<maxChars public="1"><x path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><x path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><x path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><x path="Bool"/></multiline>
		<numLines public="1" set="null"><x path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><x path="Int"/></scrollH>
		<scrollV public="1"><x path="Int"/></scrollV>
		<selectable public="1"><x path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><x path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><x path="Int"/></selectionEndIndex>
		<sharpness public="1"><x path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><x path="UInt"/></textColor>
		<textHeight public="1" set="null"><x path="Float"/></textHeight>
		<textInteractionMode public="1">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textWidth public="1" set="null"><x path="Float"/></textWidth>
		<thickness public="1"><x path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><x path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><x path="Bool"/></wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method">
			<f a="?beginIndex:?endIndex" v="-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.text.TextFormat"/>
			</f>
			<meta><m n=":value"><e>{endIndex:-1,beginIndex:-1}</e></m></meta>
		</getTextFormat>
		<getTextRuns public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":value"><e>{endIndex:2147483647,beginIndex:0}</e></m></meta>
		</getTextRuns>
		<getXMLText public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{endIndex:2147483647,beginIndex:0}</e></m></meta>
		</getXMLText>
		<insertXMLText public="1" set="method">
			<f a="beginIndex:endIndex:richText:?pasting" v=":::false">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{pasting:false}</e></m></meta>
		</insertXMLText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<x path="Bool"/>
</f></pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method">
			<f a="format:?beginIndex:?endIndex" v=":-1:-1">
				<c path="flash.text.TextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{endIndex:-1,beginIndex:-1}</e></m></meta>
		</setTextFormat>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextFieldAutoSize.hx">
		<CENTER/>
		<LEFT/>
		<NONE/>
		<RIGHT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextFieldType.hx">
		<DYNAMIC/>
		<INPUT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><x path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><x path="UInt"/></t></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><x path="Float"/></t></indent>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><x path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><x path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><x path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><x path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><x path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><x path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextFormatAlign.hx">
		<CENTER/>
		<END/>
		<JUSTIFY/>
		<LEFT/>
		<RIGHT/>
		<START/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextFormatDisplay.hx">
		<BLOCK/>
		<INLINE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextInteractionMode.hx">
		<NORMAL/>
		<SELECTION/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><x path="Int"/></charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method">
			<f a="?includeLineEndings" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{includeLineEndings:false}</e></m></meta>
		</getSelectedText>
		<getText public="1" set="method">
			<f a="beginIndex:endIndex:?includeLineEndings" v="::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{includeLineEndings:false}</e></m></meta>
		</getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1" set="method">
			<f a="x:y:?maxDistance" v="::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{maxDistance:0}</e></m></meta>
		</hitTestTextNearPos>
		<setSelectColor public="1" set="method">
			<f a="?hexColor" v="16776960">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{hexColor:16776960}</e></m></meta>
		</setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<clipboardMenu public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><x path="Bool"/></forwardAndBack>
		<loop public="1"><x path="Bool"/></loop>
		<play public="1"><x path="Bool"/></play>
		<print public="1"><x path="Bool"/></print>
		<quality public="1"><x path="Bool"/></quality>
		<rewind public="1"><x path="Bool"/></rewind>
		<save public="1"><x path="Bool"/></save>
		<zoom public="1"><x path="Bool"/></zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clear public="1"><x path="Bool"/></clear>
		<copy public="1"><x path="Bool"/></copy>
		<cut public="1"><x path="Bool"/></cut>
		<paste public="1"><x path="Bool"/></paste>
		<selectAll public="1"><x path="Bool"/></selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.IDataInput2" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{length:0,offset:0}</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.utils.IDataOutput2" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><x path="UInt"/></length>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<position public="1"><x path="UInt"/></position>
		<shareable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</shareable>
		<atomicCompareAndSwapIntAt public="1">
			<f a="byteIndex:expectedValue:newValue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapIntAt>
		<atomicCompareAndSwapLength public="1">
			<f a="expectedLength:newLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapLength>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<compress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<inflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{length:0,offset:0}</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{length:0,offset:0}</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<LZMA/>
		<ZLIB/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method">
			<f a="?weakKeys" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{weakKeys:false}</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.utils.Endian" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/Endian.hx">
		<BIG_ENDIAN/>
		<LITTLE_ENDIAN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<typedef path="flash.utils.Function" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/Namespace.hx" extern="1">
		<prefix public="1" set="null"><d/></prefix>
		<uri public="1" set="null"><c path="String"/></uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="flash.utils.Object" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/utils/Object.hx"><d/></typedef>
	<class path="flash.xml.XML" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><x path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><x path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><x path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><x path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><x path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="D:\Program Files\HaxeToolkit\haxe\std/flash/xml/XMLList.hx" extern="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="haxe.Function" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="haxe.EnumTools" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is null, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning true if
		matching succeeded and false otherwise.

		Example usage:

		```
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
	</class>
	<abstract path="haxe.Int32" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":notNull"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Log" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="D:\Program Files\HaxeToolkit\haxe\std/flash/_std/haxe/ds/ObjectMap.hx">
		<extends path="flash.utils.Dictionary"/>
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<new public="1" set="method" line="6">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/flash/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<reserved expr="&apos;???&apos;" line="28" static="1">
			<a/>
			<meta><m n=":value"><e>'???'</e></m></meta>
		</reserved>
		<h><d/></h>
		<rh><d/></rh>
		<setReserved set="method" line="57">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setReserved>
		<getReserved set="method" line="62">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getReserved>
		<existsReserved set="method" line="66">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</existsReserved>
		<new public="1" set="method" line="30">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="flash.Vector"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="455" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofData public="1" set="method" line="540" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<toString public="1" set="method" line="416"><f a=""><c path="String"/></f></toString>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="haxe.io.Input" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/Input.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="46">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="61">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<readFullBytes public="1" set="method" line="130">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="141">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readInt32 public="1" set="method" line="275">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="294">
			<f a="len">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<position public="1" get="null" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<set_position set="method" line="79"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="90" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="111" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readInt32 public="1" set="method" line="191" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</readInt32>
		<readString public="1" set="method" line="196" override="1">
			<f a="len">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</readString>
		<new public="1" set="method" line="38"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/Output.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<write public="1" set="method" line="104">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeFloat public="1" set="method" line="133">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeFloat>
		<writeInt16 public="1" set="method" line="167">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="177">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt32 public="1" set="method" line="221">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeByte] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="flash.utils.ByteArray"/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<writeFloat public="1" set="method" line="80" override="1">
			<f a="f">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</writeFloat>
		<writeInt16 public="1" set="method" line="97" override="1">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="103" override="1">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</writeUInt16>
		<writeInt32 public="1" set="method" line="109" override="1">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</writeInt32>
		<getBytes public="1" set="method" line="125">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Eof" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="D:\Program Files\HaxeToolkit\haxe\std/haxe/io/FPHelper.hx">
		<helper expr="&apos;???&apos;" line="50" static="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":value"><e>'???'</e></m></meta>
		</helper>
		<floatToI32 public="1" set="method" line="109" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floatToI32>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="jp.gr.java_conf.ennea.sound.VorbisAS" params="" file="./src/jp/gr/java_conf/ennea/sound/VorbisAS.hx">
		<manager public="1" static="1">
			<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
			<haxe_doc>* static VotbisManager instance.
	 * you can directly access to static manager, through this property.</haxe_doc>
		</manager>
		<initialize public="1" set="method" line="27" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* initialize static manager.
	 * you need call first on AS3. but need call after initSwc().</haxe_doc>
		</initialize>
		<groups public="1" get="accessor" set="null" static="1"><c path="Array"><c path="jp.gr.java_conf.ennea.sound.VorbisManager"/></c></groups>
		<get_groups set="method" line="40" static="1"><f a=""><c path="Array"><c path="jp.gr.java_conf.ennea.sound.VorbisManager"/></c></f></get_groups>
		<loadCompleted public="1" get="accessor" set="null" static="1"><c path="org.osflash.signals.Signal"/></loadCompleted>
		<get_loadCompleted set="method" line="44" static="1"><f a=""><c path="org.osflash.signals.Signal"/></f></get_loadCompleted>
		<loadFailed public="1" get="accessor" set="null" static="1"><c path="org.osflash.signals.Signal"/></loadFailed>
		<get_loadFailed set="method" line="48" static="1"><f a=""><c path="org.osflash.signals.Signal"/></f></get_loadFailed>
		<parent public="1" get="accessor" set="accessor" static="1"><c path="jp.gr.java_conf.ennea.sound.VorbisManager"/></parent>
		<get_parent set="method" line="52" static="1"><f a=""><c path="jp.gr.java_conf.ennea.sound.VorbisManager"/></f></get_parent>
		<set_parent set="method" line="53" static="1"><f a="value">
	<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
</f></set_parent>
		<mute public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></mute>
		<get_mute set="method" line="56" static="1"><f a=""><x path="Bool"/></f></get_mute>
		<set_mute set="method" line="57" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mute>
		<volume public="1" get="accessor" set="accessor" static="1"><x path="Float"/></volume>
		<get_volume set="method" line="60" static="1"><f a=""><x path="Float"/></f></get_volume>
		<set_volume set="method" line="61" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<masterVolume public="1" get="accessor" set="accessor" static="1"><x path="Float"/></masterVolume>
		<get_masterVolume set="method" line="64" static="1"><f a=""><x path="Float"/></f></get_masterVolume>
		<set_masterVolume set="method" line="65" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_masterVolume>
		<pan public="1" get="accessor" set="accessor" static="1"><x path="Float"/></pan>
		<get_pan set="method" line="68" static="1"><f a=""><x path="Float"/></f></get_pan>
		<set_pan set="method" line="69" static="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<soundTransform public="1" get="null" set="accessor" static="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<set_soundTransform set="method" line="72" static="1"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<tickEnabled public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></tickEnabled>
		<get_tickEnabled set="method" line="75" static="1"><f a=""><x path="Bool"/></f></get_tickEnabled>
		<set_tickEnabled set="method" line="76" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tickEnabled>
		<play public="1" set="method" line="78" static="1">
			<f a="type:?volume:?startTime:?loops:?allowMultiple:?allowInterrupt" v=":1:0:0:false:true">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{allowInterrupt:true,allowMultiple:false,loops:0,startTime:0,volume:1}</e></m></meta>
		</play>
		<playLoop public="1" set="method" line="82" static="1">
			<f a="type:?volume:?startTime" v=":1:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{startTime:0,volume:1}</e></m></meta>
		</playLoop>
		<playFx public="1" set="method" line="86" static="1">
			<f a="type:?volume:?startTime:?loops" v=":1:0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{loops:0,startTime:0,volume:1}</e></m></meta>
		</playFx>
		<stopAll public="1" set="method" line="90" static="1"><f a=""><x path="Void"/></f></stopAll>
		<resume public="1" set="method" line="91" static="1"><f a="type">
	<c path="String"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
</f></resume>
		<resumeAll public="1" set="method" line="92" static="1"><f a=""><x path="Void"/></f></resumeAll>
		<pause public="1" set="method" line="93" static="1"><f a="type">
	<c path="String"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
</f></pause>
		<pauseAll public="1" set="method" line="94" static="1"><f a=""><x path="Void"/></f></pauseAll>
		<fadeTo public="1" set="method" line="96" static="1">
			<f a="type:?endVolume:?duration:?stopAtZero" v=":1:1000:true">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1}</e></m></meta>
		</fadeTo>
		<fadeAllTo public="1" set="method" line="100" static="1">
			<f a="?endVolume:?duration:?stopAtZero" v="1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1}</e></m></meta>
		</fadeAllTo>
		<fadeMasterTo public="1" set="method" line="104" static="1">
			<f a="?endVolume:?duration:?stopAtZero" v="1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1}</e></m></meta>
		</fadeMasterTo>
		<fadeFrom public="1" set="method" line="108" static="1">
			<f a="type:?startVolume:?endVolume:?duration:?stopAtZero" v=":0:1:1000:true">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1,startVolume:0}</e></m></meta>
		</fadeFrom>
		<fadeAllFrom public="1" set="method" line="112" static="1">
			<f a="?startVolume:?endVolume:?duration:?stopAtZero" v="0:1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1,startVolume:0}</e></m></meta>
		</fadeAllFrom>
		<fadeMasterFrom public="1" set="method" line="116" static="1">
			<f a="?startVolume:?endVolume:?duration:?stopAtZero" v="0:1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1,startVolume:0}</e></m></meta>
		</fadeMasterFrom>
		<getSound public="1" set="method" line="120" static="1">
			<f a="type:?forceNew" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{forceNew:false}</e></m></meta>
		</getSound>
		<loadSound public="1" set="method" line="121" static="1">
			<f a="url:type:?buffer" v="::100">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{buffer:100}</e></m></meta>
		</loadSound>
		<addSound public="1" set="method" line="122" static="1"><f a="type:sound">
	<c path="String"/>
	<c path="stb.format.vorbis.flash.VorbisSound"/>
	<x path="Void"/>
</f></addSound>
		<addSoundBytes public="1" set="method" line="123" static="1"><f a="type:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></addSoundBytes>
		<removeSound public="1" set="method" line="124" static="1"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></removeSound>
		<removeAll public="1" set="method" line="125" static="1"><f a=""><x path="Void"/></f></removeAll>
		<group public="1" set="method" line="127" static="1"><f a="name">
	<c path="String"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
</f></group>
		<addTween public="1" set="method" line="129" static="1"><f a="type:startVolume:endVolume:duration:stopAtZero">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisTween"/>
</f></addTween>
		<new set="method" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* private constructor</haxe_doc>
		</new>
		<haxe_doc>* VorbisAS is static manager class...
 * this class have property and functions same to VorbisMmanager.
 * you can invoke everywhere as instantly VorbisManager instance.
 * 
 * @author Tudurao Jin</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="jp.gr.java_conf.ennea.sound.VorbisInstance" params="" file="./src/jp/gr/java_conf/ennea/sound/VorbisInstance.hx">
		<LOOP_MAX public="1" get="inline" set="null" expr="2147483647" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2147483647</e></m></meta>
			<haxe_doc>* use to Infinitely Loop.</haxe_doc>
		</LOOP_MAX>
		<manager public="1">
			<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
			<haxe_doc>* this instance is registered to manager. default is VorbisAS.</haxe_doc>
		</manager>
		<type public="1">
			<c path="String"/>
			<haxe_doc>* Specified name for this Sound</haxe_doc>
		</type>
		<url public="1">
			<c path="String"/>
			<haxe_doc>* URL this sound was loaded from.
	 * When This is null, the sound was not loaded or loaded from Bytes.</haxe_doc>
		</url>
		<sound public="1">
			<c path="stb.format.vorbis.flash.VorbisSound"/>
			<haxe_doc>* Current instance of Sound object</haxe_doc>
		</sound>
		<channel public="1">
			<c path="stb.format.vorbis.flash.VorbisSoundChannel"/>
			<haxe_doc>* Current playback channel</haxe_doc>
		</channel>
		<soundCompleted public="1">
			<c path="org.osflash.signals.Signal"/>
			<haxe_doc>* Dispatched when playback has completed</haxe_doc>
		</soundCompleted>
		<allowMultiple public="1">
			<x path="Bool"/>
			<haxe_doc>* Allow multiple concurrent instances of this Sound. If false, only one instance of this sound will ever play.</haxe_doc>
		</allowMultiple>
		<oldChannels public="1">
			<c path="Array"><c path="stb.format.vorbis.flash.VorbisSoundChannel"/></c>
			<haxe_doc>* Orphaned channels that are in the process of playing out. These will only exist when: allowMultiple = true</haxe_doc>
		</oldChannels>
		<_pauseTime><x path="Float"/></_pauseTime>
		<loops public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Float of times to loop this sound.
	 * 0 or 1 is no loop. (play Once)
	 * 2...X is play X times.
	 * -1 is infinitely loop.</haxe_doc>
		</loops>
		<_loops><x path="Int"/></_loops>
		<get_loops set="method" line="77"><f a=""><x path="Int"/></f></get_loops>
		<set_loops set="method" line="78"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_loops>
		<loopsRemaining public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Loops remaining, this will auto-decrement each time the sound loops.
	 * It will equal 0 when the sound is completed, or not looping at all. 
	 * It will equal -1 if the sound is looping infinitely.</haxe_doc>
		</loopsRemaining>
		<get_loopsRemaining set="method" line="92"><f a=""><x path="Int"/></f></get_loopsRemaining>
		<fade public="1">
			<c path="jp.gr.java_conf.ennea.sound.VorbisTween"/>
			<haxe_doc>* fade control property.
	 * if you want to check fade complete, use fade.ended signal.</haxe_doc>
		</fade>
		<mute public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Mute current sound.</haxe_doc>
		</mute>
		<_mute><x path="Bool"/></_mute>
		<get_mute set="method" line="117"><f a=""><x path="Bool"/></f></get_mute>
		<set_mute set="method" line="118"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mute>
		<isPlaying public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Indicates whether this sound is currently playing.</haxe_doc>
		</isPlaying>
		<_isPlaying><x path="Bool"/></_isPlaying>
		<get_isPlaying set="method" line="133"><f a=""><x path="Bool"/></f></get_isPlaying>
		<isPaused public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Indicates whether this sound is currently paused.</haxe_doc>
		</isPaused>
		<get_isPaused set="method" line="139"><f a=""><x path="Bool"/></f></get_isPaused>
		<position public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* position of sound in milliseconds
	 * if set new value, restart channel.</haxe_doc>
		</position>
		<get_position set="method" line="148"><f a=""><x path="Float"/></f></get_position>
		<set_position set="method" line="149"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Value between 0 and 1. You can call this while muted to change volume, and it will not break the mute.</haxe_doc>
		</volume>
		<_volume><x path="Float"/></_volume>
		<get_volume set="method" line="165"><f a=""><x path="Float"/></f></get_volume>
		<set_volume set="method" line="166"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<masterVolume public="1" get="accessor" set="accessor"><x path="Float"/></masterVolume>
		<get_masterVolume set="method" line="179"><f a=""><x path="Float"/></f></get_masterVolume>
		<set_masterVolume set="method" line="185">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Sets the master volume (the volume of the manager)
	 * Note : this will affect all sounds managed by the same manager</haxe_doc>
		</set_masterVolume>
		<mixedVolume public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Combined masterVolume and volume levels</haxe_doc>
		</mixedVolume>
		<get_mixedVolume set="method" line="193"><f a=""><x path="Float"/></f></get_mixedVolume>
		<pan public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The left-to-right panning of the sound, ranging from -1 (full pan left) to 1 (full pan right).</haxe_doc>
		</pan>
		<_pan><x path="Float"/></_pan>
		<get_pan set="method" line="204"><f a=""><x path="Float"/></f></get_pan>
		<set_pan set="method" line="205"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<soundTransform public="1" get="accessor" set="accessor"><c path="flash.media.SoundTransform"/></soundTransform>
		<_soundTransform><c path="flash.media.SoundTransform"/></_soundTransform>
		<get_soundTransform set="method" line="222"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<set_soundTransform set="method" line="227"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<play public="1" set="method" line="263">
			<f a="?volume:?startTime:?loops:?allowMultiple" v="1:0:0:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{allowMultiple:true,loops:0,startTime:0,volume:1}</e></m></meta>
			<haxe_doc>* Play this Sound. 
	 * @param volume	volume of sound.
	 * @param startTime Start position in milliseconds
	 * @param loops Number of times to loop Sound. Pass -1 to loop forever.
	 * @param allowMultiple Allow multiple concurrent instances of this Sound</haxe_doc>
		</play>
		<pause public="1" set="method" line="297">
			<f a=""><c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/></f>
			<haxe_doc>* Pause currently playing sound. Use resume() to continue playback. Pause / resume is supported for single sounds only.</haxe_doc>
		</pause>
		<resume public="1" set="method" line="309">
			<f a="?forceStart" v="false">
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{forceStart:false}</e></m></meta>
			<haxe_doc>* Resume from previously paused time. Optionally start over if it's not paused.</haxe_doc>
		</resume>
		<stop public="1" set="method" line="319">
			<f a=""><c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/></f>
			<haxe_doc>* Stop the currently playing sound and set it's position to 0</haxe_doc>
		</stop>
		<fadeTo public="1" set="method" line="332">
			<f a="endVolume:?duration:?stopAtZero" v=":1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000}</e></m></meta>
			<haxe_doc>* Fade using the current volume as the Start Volume</haxe_doc>
		</fadeTo>
		<fadeFrom public="1" set="method" line="340">
			<f a="startVolume:endVolume:?duration:?stopAtZero" v="::1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000}</e></m></meta>
			<haxe_doc>* Fade and specify both the Start Volume and End Volume.</haxe_doc>
		</fadeFrom>
		<clone public="1" set="method" line="348">
			<f a=""><c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/></f>
			<haxe_doc>* Create a duplicate of this SoundInstance</haxe_doc>
		</clone>
		<destroy public="1" set="method" line="356">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload sound from memory.</haxe_doc>
		</destroy>
		<onSoundComplete set="method" line="372">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Dispatched when Sound has finished playback</haxe_doc>
		</onSoundComplete>
		<stopChannel set="method" line="404">
			<f a="channel">
				<c path="stb.format.vorbis.flash.VorbisSoundChannel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stop the currently playing channel.</haxe_doc>
		</stopChannel>
		<stopOldChannels set="method" line="415">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Kill all orphaned channels</haxe_doc>
		</stopOldChannels>
		<updateOldChannels set="method" line="426">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Keep orphaned channels in sync with current volume</haxe_doc>
		</updateOldChannels>
		<new public="1" set="method" line="243">
			<f a="?sound:?type">
				<c path="stb.format.vorbis.flash.VorbisSound"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* initialize.
	 * @param	sound	VorbisSound.
	 * @param	type	Specified name for this Sound</haxe_doc>
		</new>
		<haxe_doc>* Vorbis Instance supported OggVorbis playback control and channel management.
 * you can use easily normal playback, multiple fx playback, and fadeIn/Out.
 * 
 * @author Tudurao Jin</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="jp.gr.java_conf.ennea.sound.VorbisManager" params="" file="./src/jp/gr/java_conf/ennea/sound/VorbisManager.hx">
		<_instances><c path="Array"><c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/></c></_instances>
		<_instancesBySound><x path="Map">
	<c path="stb.format.vorbis.flash.VorbisSound"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
</x></_instancesBySound>
		<_instancesByType><x path="Map">
	<c path="String"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
</x></_instancesByType>
		<_groupsByName><x path="Map">
	<c path="String"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
</x></_groupsByName>
		<groups public="1">
			<c path="Array"><c path="jp.gr.java_conf.ennea.sound.VorbisManager"/></c>
			<haxe_doc>* grouped manager Array.</haxe_doc>
		</groups>
		<_activeTweens><c path="Array"><c path="jp.gr.java_conf.ennea.sound.VorbisTween"/></c></_activeTweens>
		<_ticker><c path="flash.display.Shape"/></_ticker>
		<_masterTween><c path="jp.gr.java_conf.ennea.sound.VorbisTween"/></_masterTween>
		<_searching><x path="Bool"/></_searching>
		<loadCompleted public="1">
			<c path="org.osflash.signals.Signal"/>
			<haxe_doc>* Dispatched when an external Sound has completed loading.</haxe_doc>
		</loadCompleted>
		<loadFailed public="1">
			<c path="org.osflash.signals.Signal"/>
			<haxe_doc>* Dispatched when an external Sound has failed loading.</haxe_doc>
		</loadFailed>
		<parent public="1">
			<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
			<haxe_doc>* parent manager.</haxe_doc>
		</parent>
		<mute public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Mute all instances.</haxe_doc>
		</mute>
		<_mute><x path="Bool"/></_mute>
		<get_mute set="method" line="59"><f a=""><x path="Bool"/></f></get_mute>
		<set_mute set="method" line="60"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mute>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set volume on all instances</haxe_doc>
		</volume>
		<_volume><x path="Float"/></_volume>
		<get_volume set="method" line="73"><f a=""><x path="Float"/></f></get_volume>
		<set_volume set="method" line="74"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<masterVolume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set master volume, which will me multiplied on top of all existing volume levels.</haxe_doc>
		</masterVolume>
		<_masterVolume><x path="Float"/></_masterVolume>
		<get_masterVolume set="method" line="89"><f a=""><x path="Float"/></f></get_masterVolume>
		<set_masterVolume set="method" line="90"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_masterVolume>
		<pan public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set pan on all instances</haxe_doc>
		</pan>
		<_pan><x path="Float"/></_pan>
		<get_pan set="method" line="107"><f a=""><x path="Float"/></f></get_pan>
		<set_pan set="method" line="108"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<soundTransform public="1" get="null" set="accessor"><c path="flash.media.SoundTransform"/></soundTransform>
		<set_soundTransform set="method" line="121">
			<f a="value">
				<c path="flash.media.SoundTransform"/>
				<c path="flash.media.SoundTransform"/>
			</f>
			<haxe_doc>* Set soundTransform on all instances. 
	 * always return null.</haxe_doc>
		</set_soundTransform>
		<init set="method" line="142"><f a=""><x path="Void"/></f></init>
		<play public="1" set="method" line="161">
			<f a="type:?volume:?startTime:?loops:?allowMultiple:?allowInterrupt" v=":1:0:0:false:true">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{allowInterrupt:true,allowMultiple:false,loops:0,startTime:0,volume:1}</e></m></meta>
			<haxe_doc>* Play audio by type.
	 * It must already be loaded into memory using the loadSound() or addSound() or addSoundBytes APIs. 
	 * @param type	specified sound name.
	 * @param volume	sound play volume.
	 * @param startTime Starting time in milliseconds
	 * @param loops Number of times to loop audio, pass -1 to loop forever.
	 * @param allowMultiple Allow multiple, overlapping instances of this Sound (useful for SoundFX)
	 * @param allowInterrupt If this sound is currently playing, interrupt it and start at the specified StartTime. Otherwise, just update the Volume.</haxe_doc>
		</play>
		<playLoop public="1" set="method" line="183">
			<f a="type:?volume:?startTime" v=":1:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{startTime:0,volume:1}</e></m></meta>
			<haxe_doc>* Convenience function to play a sound that should loop forever.</haxe_doc>
		</playLoop>
		<playFx public="1" set="method" line="190">
			<f a="type:?volume:?startTime:?loops" v=":1:0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{loops:0,startTime:0,volume:1}</e></m></meta>
			<haxe_doc>* Convenience function to play a sound that can have overlapping instances (ie click or soundFx).</haxe_doc>
		</playFx>
		<stopAll public="1" set="method" line="197">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stop all sounds immediately.</haxe_doc>
		</stopAll>
		<resume public="1" set="method" line="206">
			<f a="type">
				<c path="String"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<haxe_doc>* Resume specific sound</haxe_doc>
		</resume>
		<resumeAll public="1" set="method" line="213">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume all paused instances.</haxe_doc>
		</resumeAll>
		<pause public="1" set="method" line="222">
			<f a="type">
				<c path="String"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<haxe_doc>* Pause a specific sound</haxe_doc>
		</pause>
		<pauseAll public="1" set="method" line="229">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause all sounds</haxe_doc>
		</pauseAll>
		<fadeTo public="1" set="method" line="238">
			<f a="type:?endVolume:?duration:?stopAtZero" v=":1:1000:true">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1}</e></m></meta>
			<haxe_doc>* Fade specific sound starting at the current volume</haxe_doc>
		</fadeTo>
		<fadeAllTo public="1" set="method" line="246">
			<f a="?endVolume:?duration:?stopAtZero" v="1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1}</e></m></meta>
			<haxe_doc>* Fade all sounds starting from their current Volume</haxe_doc>
		</fadeAllTo>
		<fadeMasterTo public="1" set="method" line="256">
			<f a="?endVolume:?duration:?stopAtZero" v="1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1}</e></m></meta>
			<haxe_doc>* Fade master volume starting at the current value</haxe_doc>
		</fadeMasterTo>
		<fadeFrom public="1" set="method" line="263">
			<f a="type:?startVolume:?endVolume:?duration:?stopAtZero" v=":0:1:1000:true">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1,startVolume:0}</e></m></meta>
			<haxe_doc>* Fade specific sound specifying both the StartVolume and EndVolume.</haxe_doc>
		</fadeFrom>
		<fadeAllFrom public="1" set="method" line="271">
			<f a="?startVolume:?endVolume:?duration:?stopAtZero" v="0:1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1,startVolume:0}</e></m></meta>
			<haxe_doc>* Fade all sounds specifying both the StartVolume and EndVolume.</haxe_doc>
		</fadeAllFrom>
		<fadeMasterFrom public="1" set="method" line="281">
			<f a="?startVolume:?endVolume:?duration:?stopAtZero" v="0:1:1000:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{stopAtZero:true,duration:1000,endVolume:1,startVolume:0}</e></m></meta>
			<haxe_doc>* Fade master volume specifying both the StartVolume and EndVolume.</haxe_doc>
		</fadeMasterFrom>
		<getSound public="1" set="method" line="291">
			<f a="type:?forceNew" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
			</f>
			<meta><m n=":value"><e>{forceNew:false}</e></m></meta>
			<haxe_doc>* Returns a SoundInstance for a specific type.
	 * @param	type	specified sound name.
	 * @param	forceNew create new Instance.
	 * @return	VorbisInstance, return null when not found.</haxe_doc>
		</getSound>
		<loadSound public="1" set="method" line="334">
			<f a="url:type">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Preload a sound from a URL or Local Path
	 * @param url External file path to the sound instance.
	 * @param type	 specific sound's name.</haxe_doc>
		</loadSound>
		<addSound public="1" set="method" line="354">
			<f a="type:sound">
				<c path="String"/>
				<c path="stb.format.vorbis.flash.VorbisSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Inject a sound that has already been loaded.
	 * @param	type  specific sound's name.
	 * @param	sound   VorbisSound instance.
	 *</haxe_doc>
		</addSound>
		<addSoundBytes public="1" set="method" line="374">
			<f a="type:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Inject a sound that has already been loaded.
	 * use OggVorbis format Binary.
	 * @param	type	specific sound's name.
	 * @param	bytes OggVorbis format binary.</haxe_doc>
		</addSoundBytes>
		<removeSound public="1" set="method" line="396">
			<f a="type">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a sound from memory.
	 * @param	type	specified sound name.</haxe_doc>
		</removeSound>
		<removeAll public="1" set="method" line="416">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload all Sound instances.</haxe_doc>
		</removeAll>
		<group public="1" set="method" line="435">
			<f a="name">
				<c path="String"/>
				<c path="jp.gr.java_conf.ennea.sound.VorbisManager"/>
			</f>
			<haxe_doc>* Return a specific group , create one if it doesn't exist.
	 * @param	name	group name.
	 * @return	VorbisManager.</haxe_doc>
		</group>
		<addMasterTween set="method" line="447"><f a="startVolume:endVolume:duration:stopAtZero">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addMasterTween>
		<addTween public="1" set="method" line="460"><f a="type:startVolume:endVolume:duration:stopAtZero">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="jp.gr.java_conf.ennea.sound.VorbisTween"/>
</f></addTween>
		<addInstance set="method" line="476"><f a="si">
	<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
	<x path="Void"/>
</f></addInstance>
		<tickEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></tickEnabled>
		<_tickEnabled><x path="Bool"/></_tickEnabled>
		<get_tickEnabled set="method" line="486"><f a=""><x path="Bool"/></f></get_tickEnabled>
		<set_tickEnabled set="method" line="487"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tickEnabled>
		<onTick set="method" line="499"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></onTick>
		<onSoundLoadComplete set="method" line="512"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></onSoundLoadComplete>
		<onSoundLoadProgress set="method" line="517"><f a="event">
	<c path="flash.events.ProgressEvent"/>
	<x path="Void"/>
</f></onSoundLoadProgress>
		<onSoundLoadError set="method" line="519"><f a="event">
	<c path="flash.events.IOErrorEvent"/>
	<x path="Void"/>
</f></onSoundLoadError>
		<new public="1" set="method" line="131"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Controls playback and loading of a group of sounds.
 * VorbisAS references a global instance of VorbisManager,
 * but you are free to instanciate your own and use them in a modular fashion.
 * ...
 * @author Tudurao Jin</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="jp.gr.java_conf.ennea.sound.VorbisTween" params="" file="./src/jp/gr/java_conf/ennea/sound/VorbisTween.hx">
		<easeOutQuad set="method" line="101" static="1">
			<f a="position:startValue:change:duration">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Equations from the man Robert Penner, see here for more:
	 * http://www.dzone.com/snippets/robert-penner-easing-equations</haxe_doc>
		</easeOutQuad>
		<easeInOutQuad set="method" line="106" static="1"><f a="position:startValue:change:duration">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></easeInOutQuad>
		<startTime public="1"><x path="Int"/></startTime>
		<startVolume public="1"><x path="Float"/></startVolume>
		<endVolume public="1"><x path="Float"/></endVolume>
		<duration public="1"><x path="Float"/></duration>
		<sound public="1"><c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/></sound>
		<isComplete public="1" set="null"><x path="Bool"/></isComplete>
		<_isMasterFade><x path="Bool"/></_isMasterFade>
		<ended public="1"><c path="org.osflash.signals.Signal"/></ended>
		<stopAtZero public="1"><x path="Bool"/></stopAtZero>
		<init public="1" set="method" line="36"><f a="startVolume:endVolume:duration">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></init>
		<update public="1" set="method" line="49">
			<f a="t">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* update of time processing.
	 * @param	t
	 * @return	true when fade is completed.</haxe_doc>
		</update>
		<end public="1" set="method" line="74">
			<f a="?applyEndVolume" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{applyEndVolume:false}</e></m></meta>
			<haxe_doc>* End the fade and dispatch ended signal. Optionally, apply the end volume as well.</haxe_doc>
		</end>
		<kill public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* End the fade silently, will not send 'ended' signal</haxe_doc>
		</kill>
		<new public="1" set="method" line="25">
			<f a="si:endVolume:duration:?isMasterFade" v=":::false">
				<c path="jp.gr.java_conf.ennea.sound.VorbisInstance"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{isMasterFade:false}</e></m></meta>
		</new>
		<haxe_doc>* VorbisTween can Fade control...
 * 
 * @author Tudurao Jin</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="org.osflash.signals.IDispatcher" params="" file="lib\as3-signals-v0.8.swc@org.osflash.signals.IDispatcher" extern="1" interface="1"><dispatch public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></dispatch></class>
	<class path="org.osflash.signals.ISignal" params="" file="lib\as3-signals-v0.8.swc@org.osflash.signals.ISignal" extern="1" interface="1">
		<valueClasses public="1"><c path="Array"><d/></c></valueClasses>
		<numListeners public="1" set="null"><x path="UInt"/></numListeners>
		<remove public="1" set="method"><f a="p1">
	<t path="flash.utils.Function"/>
	<t path="flash.utils.Function"/>
</f></remove>
		<addOnce public="1" set="method"><f a="p1">
	<t path="flash.utils.Function"/>
	<t path="flash.utils.Function"/>
</f></addOnce>
		<add public="1" set="method"><f a="p1">
	<t path="flash.utils.Function"/>
	<t path="flash.utils.Function"/>
</f></add>
	</class>
	<class path="org.osflash.signals.ISignalOwner" params="" file="lib\as3-signals-v0.8.swc@org.osflash.signals.ISignalOwner" extern="1" interface="1">
		<extends path="org.osflash.signals.IDispatcher"/>
		<extends path="org.osflash.signals.ISignal"/>
		<removeAll public="1" set="method"><f a=""><x path="Void"/></f></removeAll>
	</class>
	<class path="org.osflash.signals.Signal" params="" file="lib\as3-signals-v0.8.swc@org.osflash.signals.Signal" extern="1">
		<implements path="org.osflash.signals.IDispatcher"/>
		<implements path="org.osflash.signals.ISignalOwner"/>
		<valueClasses public="1"><c path="Array"><d/></c></valueClasses>
		<numListeners public="1" set="null"><x path="UInt"/></numListeners>
		<registerListener set="method">
			<f a="p1:?p2" v=":false">
				<t path="flash.utils.Function"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{p2:false}</e></m>
				<m n=":defParam">
					<e>"p2"</e>
					<e>false</e>
				</m>
				<m n=":protected"/>
			</meta>
		</registerListener>
		<dispatch public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></dispatch>
		<removeAll public="1" set="method"><f a=""><x path="Void"/></f></removeAll>
		<remove public="1" set="method"><f a="p1">
	<t path="flash.utils.Function"/>
	<t path="flash.utils.Function"/>
</f></remove>
		<addOnce public="1" set="method"><f a="p1">
	<t path="flash.utils.Function"/>
	<t path="flash.utils.Function"/>
</f></addOnce>
		<add public="1" set="method"><f a="p1">
	<t path="flash.utils.Function"/>
	<t path="flash.utils.Function"/>
</f></add>
		<listenersNeedCloning>
			<x path="Bool"/>
			<meta><m n=":protected"/></meta>
		</listenersNeedCloning>
		<onceListeners>
			<c path="flash.utils.Dictionary"/>
			<meta><m n=":protected"/></meta>
		</onceListeners>
		<listeners>
			<c path="Array"><d/></c>
			<meta><m n=":protected"/></meta>
		</listeners>
		<_valueClasses>
			<c path="Array"><d/></c>
			<meta><m n=":protected"/></meta>
		</_valueClasses>
		<new public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.tools.Crc32" params="" file="./src/stb/format/tools/Crc32.hx">
		<POLY get="inline" set="null" expr="0x04c11db7" line="10" static="1">
			<x path="UInt"/>
			<meta><m n=":value"><e>0x04c11db7</e></m></meta>
		</POLY>
		<table static="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></table>
		<init public="1" set="method" line="13" static="1"><f a=""><x path="Void"/></f></init>
		<update public="1" get="inline" set="null" line="28" static="1"><f a="crc:byte">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
</f></update>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.tools.MathTools" params="" file="./src/stb/format/tools/MathTools.hx">
		<ilog public="1" get="inline" set="null" line="9" static="1"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></ilog>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
	</class>
	<class path="stb.format.tools.Mdct" params="" file="./src/stb/format/tools/Mdct.hx">
		<inverseTransform public="1" get="inline" set="null" line="9" static="1"><f a="buffer:n:a:b:c:bitReverse">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Void"/>
</f></inverseTransform>
		<step3Iter0Loop get="inline" set="null" line="303" static="1"><f a="n:e:i_off:k_off:a">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></step3Iter0Loop>
		<step3InnerRLoop get="inline" set="null" line="349" static="1"><f a="lim:e:d0:k_off:a:k1">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerRLoop>
		<step3InnerSLoop get="inline" set="null" line="397" static="1"><f a="n:e:i_off:k_off:a:aOffset0:aOffset1:k0">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerSLoop>
		<iter54 get="inline" set="null" line="445" static="1"><f a="e:zOffset">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></iter54>
		<step3InnerSLoopLd654 get="inline" set="null" line="481" static="1"><f a="n:e:i_off:a:baseN">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></step3InnerSLoopLd654>
		<haxe_doc>* modified discrete cosine transform
 * @author shohei909</haxe_doc>
	</class>
	<class path="stb.format.vorbis.Reader" params="" file="./src/stb/format/vorbis/Reader.hx">
		<openFromBytes public="1" set="method" line="85" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="stb.format.vorbis.Reader"/>
</f></openFromBytes>
		<seekBytes set="method" line="90" static="1"><f a="bytes:pos">
	<c path="haxe.io.BytesInput"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seekBytes>
		<readAll public="1" set="method" line="102" static="1">
			<f a="input:output:?useFloat" v="::false">
				<c path="haxe.io.Input"/>
				<c path="haxe.io.Output"/>
				<x path="Bool"/>
				<c path="stb.format.vorbis.data.Header"/>
			</f>
			<meta><m n=":value"><e>{useFloat:false}</e></m></meta>
		</readAll>
		<decoder public="1" set="null"><c path="stb.format.vorbis.VorbisDecoder"/></decoder>
		<header public="1" get="accessor" set="null"><c path="stb.format.vorbis.data.Header"/></header>
		<get_header set="method" line="33"><f a=""><c path="stb.format.vorbis.data.Header"/></f></get_header>
		<totalSample public="1" get="accessor" set="null"><x path="Int"/></totalSample>
		<get_totalSample set="method" line="38"><f a=""><x path="Int"/></f></get_totalSample>
		<totalMillisecond public="1" get="accessor" set="null"><x path="Float"/></totalMillisecond>
		<get_totalMillisecond set="method" line="44"><f a=""><x path="Float"/></f></get_totalMillisecond>
		<currentSample public="1" get="accessor" set="accessor"><x path="Int"/></currentSample>
		<get_currentSample set="method" line="49"><f a=""><x path="Int"/></f></get_currentSample>
		<set_currentSample set="method" line="53"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentSample>
		<currentMillisecond public="1" get="accessor" set="accessor"><x path="Float"/></currentMillisecond>
		<get_currentMillisecond set="method" line="60"><f a=""><x path="Float"/></f></get_currentMillisecond>
		<set_currentMillisecond set="method" line="65"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_currentMillisecond>
		<loopStart public="1"><t path="Null"><x path="Int"/></t></loopStart>
		<loopLength public="1"><t path="Null"><x path="Int"/></t></loopLength>
		<seekFunc><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></seekFunc>
		<inputLength><x path="Int"/></inputLength>
		<read public="1" set="method" line="114">
			<f a="output:?samples:?channels:?sampleRate:?useFloat" v="::::false">
				<c path="haxe.io.Output"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{useFloat:false}</e></m></meta>
		</read>
		<clone public="1" set="method" line="129"><f a=""><c path="stb.format.vorbis.Reader"/></f></clone>
		<sampleToMillisecond public="1" get="inline" set="null" line="140"><f a="samples">
	<x path="Int"/>
	<x path="Float"/>
</f></sampleToMillisecond>
		<millisecondToSample public="1" get="inline" set="null" line="144"><f a="millseconds">
	<x path="Float"/>
	<x path="Int"/>
</f></millisecondToSample>
		<new set="method" line="76"><f a="input:seekFunc:inputLength">
	<c path="haxe.io.Input"/>
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* public domain ogg reader.
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="stb.format.vorbis._Reader.InitData" params="" file="./src/stb/format/vorbis/Reader.hx" private="1" module="stb.format.vorbis.Reader"><a>
	<seekFunc><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></seekFunc>
	<inputLength><x path="Int"/></inputLength>
	<input><c path="haxe.io.Input"/></input>
</a></typedef>
	<class path="stb.format.vorbis.VorbisDecodeState" params="" file="./src/stb/format/vorbis/VorbisDecodeState.hx">
		<INVALID_BITS public="1" get="inline" set="null" expr="-1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</INVALID_BITS>
		<page public="1" set="null"><c path="stb.format.vorbis.data.Page"/></page>
		<eof public="1" set="null"><x path="Bool"/></eof>
		<pFirst public="1" set="null"><c path="stb.format.vorbis.data.ProbedPage"/></pFirst>
		<pLast public="1" set="null"><c path="stb.format.vorbis.data.ProbedPage"/></pLast>
		<validBits public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</validBits>
		<inputPosition public="1" set="null"><x path="Int"/></inputPosition>
		<input public="1" set="null"><c path="haxe.io.Input"/></input>
		<discardSamplesDeferred public="1"><x path="Int"/></discardSamplesDeferred>
		<segments public="1" set="null"><x path="haxe.ds.Vector"><x path="Int"/></x></segments>
		<bytesInSeg public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bytesInSeg>
		<channelBuffers public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></channelBuffers>
		<channelBufferStart public="1"><x path="Int"/></channelBufferStart>
		<channelBufferEnd public="1"><x path="Int"/></channelBufferEnd>
		<currentSample public="1" set="null"><x path="Int"/></currentSample>
		<previousWindow public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></previousWindow>
		<previousLength public="1"><x path="Int"/></previousLength>
		<finalY public="1"><x path="haxe.ds.Vector"><c path="Array"><x path="Int"/></c></x></finalY>
		<firstDecode expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</firstDecode>
		<nextSeg expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</nextSeg>
		<acc><x path="UInt"/></acc>
		<lastSeg><x path="Bool"/></lastSeg>
		<lastSegWhich><x path="Int"/></lastSegWhich>
		<endSegWithKnownLoc><x path="Int"/></endSegWithKnownLoc>
		<knownLocForPacket><x path="Int"/></knownLocForPacket>
		<error><c path="stb.format.vorbis.data.ReaderError"/></error>
		<currentLoc><x path="Int"/></currentLoc>
		<currentLocValid><x path="Int"/></currentLocValid>
		<firstAudioPageOffset><x path="UInt"/></firstAudioPageOffset>
		<setup public="1" set="method" line="78"><f a="loc0:loc1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setup>
		<clone public="1" set="method" line="118"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="stb.format.vorbis.VorbisDecodeState"/>
</f></clone>
		<next public="1" set="method" line="154"><f a=""><x path="Int"/></f></next>
		<startPacket public="1" set="method" line="189"><f a=""><x path="Void"/></f></startPacket>
		<maybeStartPacket public="1" set="method" line="202"><f a=""><x path="Bool"/></f></maybeStartPacket>
		<readBits public="1" get="inline" set="null" line="230"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></readBits>
		<readPacketRaw get="inline" set="null" line="270"><f a=""><x path="Int"/></f></readPacketRaw>
		<readPacket public="1" get="inline" set="null" line="280"><f a=""><x path="Int"/></f></readPacket>
		<flushPacket public="1" get="inline" set="null" line="287"><f a=""><x path="Void"/></f></flushPacket>
		<vorbisValidate public="1" get="inline" set="null" line="294"><f a=""><x path="Void"/></f></vorbisValidate>
		<firstPageValidate public="1" set="method" line="304"><f a=""><x path="Void"/></f></firstPageValidate>
		<startFirstDecode public="1" set="method" line="314"><f a=""><x path="Void"/></f></startFirstDecode>
		<capturePattern public="1" get="inline" set="null" line="320"><f a=""><x path="Void"/></f></capturePattern>
		<skip get="inline" set="null" line="327"><f a="len">
	<x path="Int"/>
	<x path="Void"/>
</f></skip>
		<prepHuffman set="method" line="332"><f a=""><x path="Void"/></f></prepHuffman>
		<decode public="1" get="inline" set="null" line="350"><f a="c">
	<c path="stb.format.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decode>
		<decodeRaw public="1" get="inline" set="null" line="358"><f a="c">
	<c path="stb.format.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decodeRaw>
		<isLastByte public="1" get="inline" set="null" line="382"><f a=""><x path="Bool"/></f></isLastByte>
		<finishDecodePacket public="1" set="method" line="387"><f a="previousLength:n:r">
	<x path="Int"/>
	<x path="Int"/>
	<t path="stb.format.vorbis.DecodeInitialResult"/>
	<a>
		<right><x path="Int"/></right>
		<len><x path="Int"/></len>
		<left><x path="Int"/></left>
	</a>
</f></finishDecodePacket>
		<readInt32 public="1" get="inline" set="null" line="462"><f a=""><x path="Int"/></f></readInt32>
		<readByte public="1" get="inline" set="null" line="468"><f a=""><x path="Int"/></f></readByte>
		<read public="1" get="inline" set="null" line="474"><f a="n">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
</f></read>
		<readBytes public="1" get="inline" set="null" line="483"><f a="n">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readBytes>
		<readString public="1" get="inline" set="null" line="488"><f a="n">
	<x path="Int"/>
	<c path="String"/>
</f></readString>
		<getSampleNumber public="1" set="method" line="494"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="UInt"/>
	<x path="Int"/>
</f></getSampleNumber>
		<forcePageResync public="1" get="inline" set="null" line="566"><f a=""><x path="Void"/></f></forcePageResync>
		<setInputOffset public="1" get="inline" set="null" line="571"><f a="seekFunc:n">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></setInputOffset>
		<findPage public="1" set="method" line="576"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<e path="stb.format.vorbis._VorbisDecodeState.FindPageResult"/>
</f></findPage>
		<analyzePage public="1" set="method" line="650"><f a="seekFunc:h">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="stb.format.vorbis.data.Header"/>
	<c path="stb.format.vorbis.data.ProbedPage"/>
</f></analyzePage>
		<decodeScalarRaw set="method" line="783"><f a="c">
	<c path="stb.format.vorbis.data.Codebook"/>
	<x path="Int"/>
</f></decodeScalarRaw>
		<new public="1" set="method" line="70"><f a="input">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="stb.format.vorbis._VorbisDecodeState.FindPageResult" params="" file="./src/stb/format/vorbis/VorbisDecodeState.hx" private="1" module="stb.format.vorbis.VorbisDecodeState">
		<Found a="end:last">
			<x path="Int"/>
			<x path="Bool"/>
		</Found>
		<NotFound/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="stb.format.vorbis.VorbisDecoder" params="" file="./src/stb/format/vorbis/VorbisDecoder.hx">
		<start public="1" set="method" line="72" static="1"><f a="input">
	<c path="haxe.io.Input"/>
	<c path="stb.format.vorbis.VorbisDecoder"/>
</f></start>
		<previousWindow><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></previousWindow>
		<previousLength><x path="Int"/></previousLength>
		<finalY><x path="haxe.ds.Vector"><c path="Array"><x path="Int"/></c></x></finalY>
		<a><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></a>
		<b><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></b>
		<c><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></c>
		<window><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></window>
		<bitReverseData><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></bitReverseData>
		<channelBuffers><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></channelBuffers>
		<channelBufferStart><x path="Int"/></channelBufferStart>
		<channelBufferEnd><x path="Int"/></channelBufferEnd>
		<header public="1" set="null"><c path="stb.format.vorbis.data.Header"/></header>
		<currentSample public="1" set="null"><x path="Int"/></currentSample>
		<totalSample public="1" set="null"><t path="Null"><x path="Int"/></t></totalSample>
		<decodeState><c path="stb.format.vorbis.VorbisDecodeState"/></decodeState>
		<read public="1" set="method" line="82"><f a="output:samples:channels:sampleRate:useFloat">
	<c path="haxe.io.Output"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></read>
		<skipSamples public="1" set="method" line="147"><f a="len">
	<x path="Int"/>
	<x path="Int"/>
</f></skipSamples>
		<setupSampleNumber public="1" set="method" line="166"><f a="seekFunc:inputLength">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Void"/>
</f></setupSampleNumber>
		<seek public="1" set="method" line="173"><f a="seekFunc:inputLength:sampleNumber">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seek>
		<seekFrameFromPage public="1" set="method" line="275"><f a="seekFunc:pageStart:firstSample:targetSample">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></seekFrameFromPage>
		<clone public="1" set="method" line="338"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<c path="stb.format.vorbis.VorbisDecoder"/>
</f></clone>
		<ensurePosition public="1" set="method" line="370"><f a="seekFunc">
	<f a="">
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></ensurePosition>
		<getFrameFloat set="method" line="374"><f a=""><x path="Int"/></f></getFrameFloat>
		<pumpFirstFrame set="method" line="389"><f a=""><x path="Void"/></f></pumpFirstFrame>
		<finishFrame set="method" line="393"><f a="r">
	<t path="stb.format.vorbis.DecodePacketResult"/>
	<x path="Int"/>
</f></finishFrame>
		<getWindow set="method" line="453"><f a="len">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></getWindow>
		<initBlocksize set="method" line="466"><f a="bs:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></initBlocksize>
		<inverseMdct set="method" line="480"><f a="buffer:n:blocktype">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></inverseMdct>
		<decodePacket set="method" line="485"><f a=""><t path="stb.format.vorbis.DecodePacketResult"/></f></decodePacket>
		<decodeInitial set="method" line="495"><f a=""><t path="stb.format.vorbis.DecodeInitialResult"/></f></decodeInitial>
		<decodePacketRest set="method" line="552"><f a="r">
	<t path="stb.format.vorbis.DecodeInitialResult"/>
	<t path="stb.format.vorbis.DecodePacketResult"/>
</f></decodePacketRest>
		<new set="method" line="44"><f a="header:decodeState">
	<c path="stb.format.vorbis.data.Header"/>
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="stb.format.vorbis.DecodePacketResult" params="" file="./src/stb/format/vorbis/VorbisDecoder.hx" module="stb.format.vorbis.VorbisDecoder"><a>
	<right><x path="Int"/></right>
	<len><x path="Int"/></len>
	<left><x path="Int"/></left>
</a></typedef>
	<typedef path="stb.format.vorbis.DecodeInitialResult" params="" file="./src/stb/format/vorbis/VorbisDecoder.hx" module="stb.format.vorbis.VorbisDecoder"><a>
	<right><t path="stb.format.vorbis._VorbisDecoder.Range"/></right>
	<mode><x path="Int"/></mode>
	<left><t path="stb.format.vorbis._VorbisDecoder.Range"/></left>
</a></typedef>
	<typedef path="stb.format.vorbis._VorbisDecoder.Range" params="" file="./src/stb/format/vorbis/VorbisDecoder.hx" private="1" module="stb.format.vorbis.VorbisDecoder"><a>
	<start><x path="Int"/></start>
	<end><x path="Int"/></end>
</a></typedef>
	<class path="stb.format.vorbis.VorbisTools" params="" file="./src/stb/format/vorbis/VorbisTools.hx">
		<EOP public="1" get="inline" set="null" expr="-1" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</EOP>
		<integerDivideTable public="1" static="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></integerDivideTable>
		<M_PI get="inline" set="null" expr="3.14159265358979323846264" line="18" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3.14159265358979323846264</e></m></meta>
		</M_PI>
		<DIVTAB_NUMER get="inline" set="null" expr="32" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</DIVTAB_NUMER>
		<DIVTAB_DENOM get="inline" set="null" expr="64" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>64</e></m></meta>
		</DIVTAB_DENOM>
		<INVERSE_DB_TABLE public="1" expr="[1.0649863e-07,1.1341951e-07,1.2079015e-07,1.2863978e-07,1.3699951e-07,1.4590251e-07,1.5538408e-07,1.6548181e-07,1.7623575e-07,1.8768855e-07,1.9988561e-07,2.1287530e-07,2.2670913e-07,2.4144197e-07,2.5713223e-07,2.7384213e-07,2.9163793e-07,3.1059021e-07,3.3077411e-07,3.5226968e-07,3.7516214e-07,3.9954229e-07,4.2550680e-07,4.5315863e-07,4.8260743e-07,5.1396998e-07,5.4737065e-07,5.8294187e-07,6.2082472e-07,6.6116941e-07,7.0413592e-07,7.4989464e-07,7.9862701e-07,8.5052630e-07,9.0579828e-07,9.6466216e-07,1.0273513e-06,1.0941144e-06,1.1652161e-06,1.2409384e-06,1.3215816e-06,1.4074654e-06,1.4989305e-06,1.5963394e-06,1.7000785e-06,1.8105592e-06,1.9282195e-06,2.0535261e-06,2.1869758e-06,2.3290978e-06,2.4804557e-06,2.6416497e-06,2.8133190e-06,2.9961443e-06,3.1908506e-06,3.3982101e-06,3.6190449e-06,3.8542308e-06,4.1047004e-06,4.3714470e-06,4.6555282e-06,4.9580707e-06,5.2802740e-06,5.6234160e-06,5.9888572e-06,6.3780469e-06,6.7925283e-06,7.2339451e-06,7.7040476e-06,8.2047000e-06,8.7378876e-06,9.3057248e-06,9.9104632e-06,1.0554501e-05,1.1240392e-05,1.1970856e-05,1.2748789e-05,1.3577278e-05,1.4459606e-05,1.5399272e-05,1.6400004e-05,1.7465768e-05,1.8600792e-05,1.9809576e-05,2.1096914e-05,2.2467911e-05,2.3928002e-05,2.5482978e-05,2.7139006e-05,2.8902651e-05,3.0780908e-05,3.2781225e-05,3.4911534e-05,3.7180282e-05,3.9596466e-05,4.2169667e-05,4.4910090e-05,4.7828601e-05,5.0936773e-05,5.4246931e-05,5.7772202e-05,6.1526565e-05,6.5524908e-05,6.9783085e-05,7.4317983e-05,7.9147585e-05,8.4291040e-05,8.9768747e-05,9.5602426e-05,0.00010181521,0.00010843174,0.00011547824,0.00012298267,0.00013097477,0.00013948625,0.00014855085,0.00015820453,0.00016848555,0.00017943469,0.00019109536,0.00020351382,0.00021673929,0.00023082423,0.00024582449,0.00026179955,0.00027881276,0.00029693158,0.00031622787,0.00033677814,0.00035866388,0.00038197188,0.00040679456,0.00043323036,0.00046138411,0.00049136745,0.00052329927,0.00055730621,0.00059352311,0.00063209358,0.00067317058,0.00071691700,0.00076350630,0.00081312324,0.00086596457,0.00092223983,0.00098217216,0.0010459992,0.0011139742,0.0011863665,0.0012634633,0.0013455702,0.0014330129,0.0015261382,0.0016253153,0.0017309374,0.0018434235,0.0019632195,0.0020908006,0.0022266726,0.0023713743,0.0025254795,0.0026895994,0.0028643847,0.0030505286,0.0032487691,0.0034598925,0.0036847358,0.0039241906,0.0041792066,0.0044507950,0.0047400328,0.0050480668,0.0053761186,0.0057254891,0.0060975636,0.0064938176,0.0069158225,0.0073652516,0.0078438871,0.0083536271,0.0088964928,0.009474637,0.010090352,0.010746080,0.011444421,0.012188144,0.012980198,0.013823725,0.014722068,0.015678791,0.016697687,0.017782797,0.018938423,0.020169149,0.021479854,0.022875735,0.024362330,0.025945531,0.027631618,0.029427276,0.031339626,0.033376252,0.035545228,0.037855157,0.040315199,0.042935108,0.045725273,0.048696758,0.051861348,0.055231591,0.058820850,0.062643361,0.066714279,0.071049749,0.075666962,0.080584227,0.085821044,0.091398179,0.097337747,0.10366330,0.11039993,0.11757434,0.12521498,0.13335215,0.14201813,0.15124727,0.16107617,0.17154380,0.18269168,0.19456402,0.20720788,0.22067342,0.23501402,0.25028656,0.26655159,0.28387361,0.30232132,0.32196786,0.34289114,0.36517414,0.38890521,0.41417847,0.44109412,0.46975890,0.50028648,0.53279791,0.56742212,0.60429640,0.64356699,0.68538959,0.72993007,0.77736504,0.82788260,0.88168307,0.9389798,1.0]" line="23" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0649863e-07,1.1341951e-07,1.2079015e-07,1.2863978e-07,1.3699951e-07,1.4590251e-07,1.5538408e-07,1.6548181e-07,1.7623575e-07,1.8768855e-07,1.9988561e-07,2.1287530e-07,2.2670913e-07,2.4144197e-07,2.5713223e-07,2.7384213e-07,2.9163793e-07,3.1059021e-07,3.3077411e-07,3.5226968e-07,3.7516214e-07,3.9954229e-07,4.2550680e-07,4.5315863e-07,4.8260743e-07,5.1396998e-07,5.4737065e-07,5.8294187e-07,6.2082472e-07,6.6116941e-07,7.0413592e-07,7.4989464e-07,7.9862701e-07,8.5052630e-07,9.0579828e-07,9.6466216e-07,1.0273513e-06,1.0941144e-06,1.1652161e-06,1.2409384e-06,1.3215816e-06,1.4074654e-06,1.4989305e-06,1.5963394e-06,1.7000785e-06,1.8105592e-06,1.9282195e-06,2.0535261e-06,2.1869758e-06,2.3290978e-06,2.4804557e-06,2.6416497e-06,2.8133190e-06,2.9961443e-06,3.1908506e-06,3.3982101e-06,3.6190449e-06,3.8542308e-06,4.1047004e-06,4.3714470e-06,4.6555282e-06,4.9580707e-06,5.2802740e-06,5.6234160e-06,5.9888572e-06,6.3780469e-06,6.7925283e-06,7.2339451e-06,7.7040476e-06,8.2047000e-06,8.7378876e-06,9.3057248e-06,9.9104632e-06,1.0554501e-05,1.1240392e-05,1.1970856e-05,1.2748789e-05,1.3577278e-05,1.4459606e-05,1.5399272e-05,1.6400004e-05,1.7465768e-05,1.8600792e-05,1.9809576e-05,2.1096914e-05,2.2467911e-05,2.3928002e-05,2.5482978e-05,2.7139006e-05,2.8902651e-05,3.0780908e-05,3.2781225e-05,3.4911534e-05,3.7180282e-05,3.9596466e-05,4.2169667e-05,4.4910090e-05,4.7828601e-05,5.0936773e-05,5.4246931e-05,5.7772202e-05,6.1526565e-05,6.5524908e-05,6.9783085e-05,7.4317983e-05,7.9147585e-05,8.4291040e-05,8.9768747e-05,9.5602426e-05,0.00010181521,0.00010843174,0.00011547824,0.00012298267,0.00013097477,0.00013948625,0.00014855085,0.00015820453,0.00016848555,0.00017943469,0.00019109536,0.00020351382,0.00021673929,0.00023082423,0.00024582449,0.00026179955,0.00027881276,0.00029693158,0.00031622787,0.00033677814,0.00035866388,0.00038197188,0.00040679456,0.00043323036,0.00046138411,0.00049136745,0.00052329927,0.00055730621,0.00059352311,0.00063209358,0.00067317058,0.00071691700,0.00076350630,0.00081312324,0.00086596457,0.00092223983,0.00098217216,0.0010459992,0.0011139742,0.0011863665,0.0012634633,0.0013455702,0.0014330129,0.0015261382,0.0016253153,0.0017309374,0.0018434235,0.0019632195,0.0020908006,0.0022266726,0.0023713743,0.0025254795,0.0026895994,0.0028643847,0.0030505286,0.0032487691,0.0034598925,0.0036847358,0.0039241906,0.0041792066,0.0044507950,0.0047400328,0.0050480668,0.0053761186,0.0057254891,0.0060975636,0.0064938176,0.0069158225,0.0073652516,0.0078438871,0.0083536271,0.0088964928,0.009474637,0.010090352,0.010746080,0.011444421,0.012188144,0.012980198,0.013823725,0.014722068,0.015678791,0.016697687,0.017782797,0.018938423,0.020169149,0.021479854,0.022875735,0.024362330,0.025945531,0.027631618,0.029427276,0.031339626,0.033376252,0.035545228,0.037855157,0.040315199,0.042935108,0.045725273,0.048696758,0.051861348,0.055231591,0.058820850,0.062643361,0.066714279,0.071049749,0.075666962,0.080584227,0.085821044,0.091398179,0.097337747,0.10366330,0.11039993,0.11757434,0.12521498,0.13335215,0.14201813,0.15124727,0.16107617,0.17154380,0.18269168,0.19456402,0.20720788,0.22067342,0.23501402,0.25028656,0.26655159,0.28387361,0.30232132,0.32196786,0.34289114,0.36517414,0.38890521,0.41417847,0.44109412,0.46975890,0.50028648,0.53279791,0.56742212,0.60429640,0.64356699,0.68538959,0.72993007,0.77736504,0.82788260,0.88168307,0.9389798,1.0]</e></m></meta>
		</INVERSE_DB_TABLE>
		<assert public="1" get="inline" set="null" line="90" static="1"><f a="b:?p">
	<x path="Bool"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></assert>
		<neighbors public="1" get="inline" set="null" line="98" static="1"><f a="x:n">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<a>
		<low><x path="Int"/></low>
		<high><x path="Int"/></high>
	</a>
</f></neighbors>
		<floatUnpack public="1" get="inline" set="null" line="115" static="1"><f a="x">
	<x path="UInt"/>
	<x path="Float"/>
</f></floatUnpack>
		<bitReverse public="1" get="inline" set="null" line="125" static="1"><f a="n">
	<x path="UInt"/>
	<x path="UInt"/>
</f></bitReverse>
		<pointCompare public="1" get="inline" set="null" line="134" static="1"><f a="a:b">
	<c path="stb.format.vorbis.data.IntPoint"/>
	<c path="stb.format.vorbis.data.IntPoint"/>
	<x path="Int"/>
</f></pointCompare>
		<uintAsc public="1" set="method" line="138" static="1"><f a="a:b">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></uintAsc>
		<lookup1Values public="1" set="method" line="148" static="1"><f a="entries:dim">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lookup1Values>
		<computeWindow public="1" set="method" line="160" static="1"><f a="n:window">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></computeWindow>
		<square public="1" set="method" line="168" static="1"><f a="f">
	<x path="Float"/>
	<x path="Float"/>
</f></square>
		<computeBitReverse public="1" set="method" line="172" static="1"><f a="n:rev">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Void"/>
</f></computeBitReverse>
		<computeTwiddleFactors public="1" set="method" line="182" static="1"><f a="n:af:bf:cf">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></computeTwiddleFactors>
		<drawLine public="1" set="method" line="205" static="1"><f a="output:x0:y0:x1:y1:n">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawLine>
		<stbProf public="1" set="method" static="1"><f a="i">
	<d/>
	<d/>
</f></stbProf>
		<predictPoint public="1" get="inline" set="null" line="264" static="1"><f a="x:x0:x1:y0:y1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></predictPoint>
		<emptyFloatVector public="1" get="inline" set="null" line="274" static="1"><f a="len">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></emptyFloatVector>
		<copyVector public="1" set="method" line="284" static="1"><f a="source">
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
</f></copyVector>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Codebook" params="" file="./src/stb/format/vorbis/data/Codebook.hx">
		<NO_CODE public="1" get="inline" set="null" expr="255" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>255</e></m></meta>
		</NO_CODE>
		<read public="1" set="method" line="37" static="1"><f a="decodeState">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<c path="stb.format.vorbis.data.Codebook"/>
</f></read>
		<delay expr="0" line="480" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</delay>
		<dimensions public="1"><x path="Int"/></dimensions>
		<entries public="1"><x path="Int"/></entries>
		<codewordLengths public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></codewordLengths>
		<minimumValue public="1"><x path="Float"/></minimumValue>
		<deltaValue public="1"><x path="Float"/></deltaValue>
		<valueBits public="1"><x path="Int"/></valueBits>
		<lookupType public="1"><x path="Int"/></lookupType>
		<sequenceP public="1"><x path="Bool"/></sequenceP>
		<sparse public="1"><x path="Bool"/></sparse>
		<lookupValues public="1"><x path="UInt"/></lookupValues>
		<multiplicands public="1"><x path="haxe.ds.Vector"><x path="Float"/></x></multiplicands>
		<codewords public="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></codewords>
		<fastHuffman public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></fastHuffman>
		<sortedCodewords public="1"><c path="Array"><x path="UInt"/></c></sortedCodewords>
		<sortedValues public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></sortedValues>
		<sortedEntries public="1"><x path="Int"/></sortedEntries>
		<addEntry get="inline" set="null" line="187"><f a="huffCode:symbol:count:len:values">
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Void"/>
</f></addEntry>
		<includeInSort get="inline" set="null" line="198"><f a="len">
	<x path="Int"/>
	<x path="Bool"/>
</f></includeInSort>
		<computeCodewords set="method" line="213"><f a="len:n:values">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Bool"/>
</f></computeCodewords>
		<computeSortedHuffman set="method" line="283"><f a="lengths:values">
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="haxe.ds.Vector"><x path="UInt"/></x>
	<x path="Void"/>
</f></computeSortedHuffman>
		<computeAcceleratedHuffman set="method" line="340"><f a=""><x path="Void"/></f></computeAcceleratedHuffman>
		<codebookDecode set="method" line="366"><f a="decodeState:output:offset:len">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></codebookDecode>
		<codebookDecodeStep set="method" line="414"><f a="decodeState:output:offset:len:step">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></codebookDecodeStep>
		<decodeStart get="inline" set="null" line="457"><f a="decodeState">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="Int"/>
</f></decodeStart>
		<decodeDeinterleaveRepeat public="1" set="method" line="482"><f a="decodeState:residueBuffers:ch:cInter:pInter:len:totalDecode">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<a>
		<pInter><x path="Int"/></pInter>
		<cInter><x path="Int"/></cInter>
	</a>
</f></decodeDeinterleaveRepeat>
		<residueDecode public="1" set="method" line="573"><f a="decodeState:target:offset:n:rtype">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></residueDecode>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Comment" params="" file="./src/stb/format/vorbis/data/Comment.hx">
		<data public="1" set="null"><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</x></data>
		<title public="1" get="accessor" set="null"><c path="String"/></title>
		<get_title set="method" line="11"><f a=""><t path="Null"><c path="String"/></t></f></get_title>
		<loopStart public="1" get="accessor" set="null"><t path="Null"><x path="Int"/></t></loopStart>
		<get_loopStart set="method" line="16"><f a=""><t path="Null"><x path="Int"/></t></f></get_loopStart>
		<loopLength public="1" get="accessor" set="null"><t path="Null"><x path="Int"/></t></loopLength>
		<get_loopLength set="method" line="21"><f a=""><t path="Null"><x path="Int"/></t></f></get_loopLength>
		<version public="1" get="accessor" set="null"><c path="String"/></version>
		<get_version set="method" line="26"><f a=""><t path="Null"><c path="String"/></t></f></get_version>
		<album public="1" get="accessor" set="null"><c path="String"/></album>
		<get_album set="method" line="31"><f a=""><t path="Null"><c path="String"/></t></f></get_album>
		<organization public="1" get="accessor" set="null"><c path="String"/></organization>
		<get_organization set="method" line="36"><f a=""><t path="Null"><c path="String"/></t></f></get_organization>
		<tracknumber public="1" get="accessor" set="null"><c path="String"/></tracknumber>
		<get_tracknumber set="method" line="41"><f a=""><t path="Null"><c path="String"/></t></f></get_tracknumber>
		<performer public="1" get="accessor" set="null"><c path="String"/></performer>
		<get_performer set="method" line="46"><f a=""><t path="Null"><c path="String"/></t></f></get_performer>
		<copyright public="1" get="accessor" set="null"><c path="String"/></copyright>
		<get_copyright set="method" line="51"><f a=""><t path="Null"><c path="String"/></t></f></get_copyright>
		<license public="1" get="accessor" set="null"><c path="String"/></license>
		<get_license set="method" line="56"><f a=""><t path="Null"><c path="String"/></t></f></get_license>
		<artist public="1" get="accessor" set="null"><c path="String"/></artist>
		<get_artist set="method" line="61"><f a=""><t path="Null"><c path="String"/></t></f></get_artist>
		<description public="1" get="accessor" set="null"><c path="String"/></description>
		<get_description set="method" line="66"><f a=""><t path="Null"><c path="String"/></t></f></get_description>
		<genre public="1" get="accessor" set="null"><c path="String"/></genre>
		<get_genre set="method" line="71"><f a=""><t path="Null"><c path="String"/></t></f></get_genre>
		<date public="1" get="accessor" set="null"><c path="String"/></date>
		<get_date set="method" line="76"><f a=""><t path="Null"><c path="String"/></t></f></get_date>
		<location public="1" get="accessor" set="null"><c path="String"/></location>
		<get_location set="method" line="81"><f a=""><t path="Null"><c path="String"/></t></f></get_location>
		<contact public="1" get="accessor" set="null"><c path="String"/></contact>
		<get_contact set="method" line="86"><f a=""><t path="Null"><c path="String"/></t></f></get_contact>
		<isrc public="1" get="accessor" set="null"><c path="String"/></isrc>
		<get_isrc set="method" line="91"><f a=""><t path="Null"><c path="String"/></t></f></get_isrc>
		<artists public="1" get="accessor" set="null"><c path="Array"><c path="String"/></c></artists>
		<get_artists set="method" line="96"><f a=""><t path="Null"><t path="Null"><c path="Array"><c path="String"/></c></t></t></f></get_artists>
		<add public="1" set="method" line="104"><f a="key:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<getString public="1" set="method" line="113"><f a="key">
	<c path="String"/>
	<t path="Null"><c path="String"/></t>
</f></getString>
		<getArray public="1" set="method" line="122"><f a="key">
	<c path="String"/>
	<t path="Null"><t path="Null"><c path="Array"><c path="String"/></c></t></t>
</f></getArray>
		<new public="1" set="method" line="100"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Floor" params="" file="./src/stb/format/vorbis/data/Floor.hx">
		<read public="1" set="method" line="22" static="1"><f a="decodeState:codebooks">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Codebook"/></x>
	<c path="stb.format.vorbis.data.Floor"/>
</f></read>
		<floor0 public="1"><c path="stb.format.vorbis.data.Floor0"/></floor0>
		<floor1 public="1"><c path="stb.format.vorbis.data.Floor1"/></floor1>
		<type public="1"><x path="Int"/></type>
		<new set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Floor0" params="" file="./src/stb/format/vorbis/data/Floor.hx" module="stb.format.vorbis.data.Floor">
		<order public="1"><x path="Int"/></order>
		<rate public="1"><x path="Int"/></rate>
		<barkMapSize public="1"><x path="Int"/></barkMapSize>
		<amplitudeBits public="1"><x path="Int"/></amplitudeBits>
		<amplitudeOffset public="1"><x path="Int"/></amplitudeOffset>
		<numberOfBooks public="1"><x path="Int"/></numberOfBooks>
		<bookList public="1"><x path="haxe.ds.Vector"><x path="UInt"/></x></bookList>
		<new public="1" set="method" line="130"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Floor1" params="" file="./src/stb/format/vorbis/data/Floor.hx" module="stb.format.vorbis.data.Floor">
		<partitions public="1"><x path="Int"/></partitions>
		<partitionClassList public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></partitionClassList>
		<classDimensions public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classDimensions>
		<classSubclasses public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classSubclasses>
		<classMasterbooks public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></classMasterbooks>
		<subclassBooks public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></subclassBooks>
		<xlist public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></xlist>
		<sortedOrder public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></sortedOrder>
		<neighbors public="1"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></neighbors>
		<floor1Multiplier public="1"><x path="Int"/></floor1Multiplier>
		<rangebits public="1"><x path="Int"/></rangebits>
		<values public="1"><x path="Int"/></values>
		<new public="1" set="method" line="149"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Header" params="" file="./src/stb/format/vorbis/data/Header.hx">
		<PACKET_ID public="1" get="inline" set="null" expr="1" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</PACKET_ID>
		<PACKET_COMMENT public="1" get="inline" set="null" expr="3" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</PACKET_COMMENT>
		<PACKET_SETUP public="1" get="inline" set="null" expr="5" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</PACKET_SETUP>
		<read public="1" set="method" line="41" static="1"><f a="decodeState">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<c path="stb.format.vorbis.data.Header"/>
</f></read>
		<maximumBitRate public="1" set="null"><x path="UInt"/></maximumBitRate>
		<nominalBitRate public="1" set="null"><x path="UInt"/></nominalBitRate>
		<minimumBitRate public="1" set="null"><x path="UInt"/></minimumBitRate>
		<sampleRate public="1" set="null"><x path="UInt"/></sampleRate>
		<channel public="1" set="null"><x path="Int"/></channel>
		<blocksize0 public="1" set="null"><x path="Int"/></blocksize0>
		<blocksize1 public="1" set="null"><x path="Int"/></blocksize1>
		<codebooks public="1" set="null"><x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Codebook"/></x></codebooks>
		<floorConfig public="1" set="null"><x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Floor"/></x></floorConfig>
		<residueConfig public="1" set="null"><x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Residue"/></x></residueConfig>
		<mapping public="1" set="null"><x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Mapping"/></x></mapping>
		<modes public="1" set="null"><x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Mode"/></x></modes>
		<comment public="1" set="null"><c path="stb.format.vorbis.data.Comment"/></comment>
		<vendor public="1" set="null"><c path="String"/></vendor>
		<new set="method" line="37"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.IntPoint" params="" file="./src/stb/format/vorbis/data/IntPoint.hx">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Mapping" params="" file="./src/stb/format/vorbis/data/Mapping.hx">
		<read public="1" set="method" line="17" static="1"><f a="decodeState:channels">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="Int"/>
	<c path="stb.format.vorbis.data.Mapping"/>
</f></read>
		<couplingSteps public="1"><x path="Int"/></couplingSteps>
		<chan public="1"><x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.MappingChannel"/></x></chan>
		<submaps public="1"><x path="Int"/></submaps>
		<submapFloor public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></submapFloor>
		<submapResidue public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></submapResidue>
		<doFloor public="1" set="method" line="88"><f a="floors:i:n:target:finalY:step2Flag">
	<x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Floor"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<c path="Array"><x path="Int"/></c>
	<x path="haxe.ds.Vector"><x path="Bool"/></x>
	<x path="Void"/>
</f></doFloor>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.MappingChannel" params="" file="./src/stb/format/vorbis/data/Mapping.hx" module="stb.format.vorbis.data.Mapping">
		<magnitude public="1"><x path="Int"/></magnitude>
		<angle public="1"><x path="Int"/></angle>
		<mux public="1"><x path="Int"/></mux>
		<new public="1" set="method" line="125"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Mode" params="" file="./src/stb/format/vorbis/data/Mode.hx">
		<read public="1" set="method" line="15" static="1"><f a="decodeState">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<c path="stb.format.vorbis.data.Mode"/>
</f></read>
		<blockflag public="1"><x path="Bool"/></blockflag>
		<mapping public="1"><x path="Int"/></mapping>
		<windowtype public="1"><x path="Int"/></windowtype>
		<transformtype public="1"><x path="Int"/></transformtype>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Page" params="" file="./src/stb/format/vorbis/data/Page.hx">
		<flag public="1" set="null"><x path="Int"/></flag>
		<clone public="1" set="method" line="18"><f a=""><c path="stb.format.vorbis.data.Page"/></f></clone>
		<start public="1" set="method" line="25"><f a="decodeState">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></start>
		<startWithoutCapturePattern public="1" set="method" line="31"><f a="decodeState">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="Void"/>
</f></startWithoutCapturePattern>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.PageFlag" params="" file="./src/stb/format/vorbis/data/Page.hx" module="stb.format.vorbis.data.Page">
		<CONTINUED_PACKET public="1" get="inline" set="null" expr="1" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</CONTINUED_PACKET>
		<FIRST_PAGE public="1" get="inline" set="null" expr="2" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</FIRST_PAGE>
		<LAST_PAGE public="1" get="inline" set="null" expr="4" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</LAST_PAGE>
	</class>
	<class path="stb.format.vorbis.data.ProbedPage" params="" file="./src/stb/format/vorbis/data/ProbedPage.hx">
		<pageStart public="1"><x path="Int"/></pageStart>
		<pageEnd public="1"><x path="Int"/></pageEnd>
		<afterPreviousPageStart public="1"><x path="Int"/></afterPreviousPageStart>
		<firstDecodedSample public="1"><t path="Null"><x path="Int"/></t></firstDecodedSample>
		<lastDecodedSample public="1"><t path="Null"><x path="Int"/></t></lastDecodedSample>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.ReaderError" params="" file="./src/stb/format/vorbis/data/ReaderError.hx">
		<type public="1" set="null"><e path="stb.format.vorbis.data.ReaderErrorType"/></type>
		<message public="1" set="null"><c path="String"/></message>
		<posInfos public="1" set="null"><t path="haxe.PosInfos"/></posInfos>
		<new public="1" set="method" line="14">
			<f a="type:?message:?posInfos" v=":&quot;&quot;:">
				<e path="stb.format.vorbis.data.ReaderErrorType"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{message:""}</e></m></meta>
		</new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="stb.format.vorbis.data.ReaderErrorType" params="" file="./src/stb/format/vorbis/data/ReaderError.hx" module="stb.format.vorbis.data.ReaderError">
		<NEED_MORE_DATA/>
		<INVALID_API_MIXING/>
		<OUTOFMEM/>
		<FEATURE_NOT_SUPPORTED/>
		<TOO_MANY_CHANNELS/>
		<FILE_OPEN_FAILURE/>
		<SEEK_WITHOUT_LENGTH/>
		<UNEXPECTED_EOF/>
		<SEEK_INVALID/>
		<INVALID_SETUP/>
		<INVALID_STREAM/>
		<MISSING_CAPTURE_PATTERN/>
		<INVALID_STREAM_STRUCTURE_VERSION/>
		<CONTINUED_PACKET_FLAG_INVALID/>
		<INCORRECT_STREAM_SERIAL_NUMBER/>
		<INVALID_FIRST_PAGE/>
		<BAD_PACKET_TYPE/>
		<CANT_FIND_LAST_PAGE/>
		<SEEK_FAILED/>
		<OTHER/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="stb.format.vorbis.data.Residue" params="" file="./src/stb/format/vorbis/data/Residue.hx">
		<read public="1" set="method" line="24" static="1"><f a="decodeState:codebooks">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<x path="haxe.ds.Vector"><c path="stb.format.vorbis.data.Codebook"/></x>
	<c path="stb.format.vorbis.data.Residue"/>
</f></read>
		<begin public="1" set="null"><x path="UInt"/></begin>
		<end public="1" set="null"><x path="UInt"/></end>
		<partSize public="1" set="null"><x path="UInt"/></partSize>
		<classifications public="1" set="null"><x path="Int"/></classifications>
		<classbook public="1" set="null"><x path="Int"/></classbook>
		<classdata public="1" set="null"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></classdata>
		<residueBooks public="1" set="null"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Int"/></x></x></residueBooks>
		<type public="1" set="null"><x path="Int"/></type>
		<decode public="1" set="method" line="83"><f a="decodeState:header:residueBuffers:ch:n:doNotDecode:channelBuffers">
	<c path="stb.format.vorbis.VorbisDecodeState"/>
	<c path="stb.format.vorbis.data.Header"/>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Bool"/></x>
	<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
	<x path="Void"/>
</f></decode>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.data.Setting" params="" file="./src/stb/format/vorbis/data/Setting.hx">
		<MAX_CHANNELS public="1" get="inline" set="null" expr="16" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</MAX_CHANNELS>
		<PUSHDATA_CRC_COUNT public="1" get="inline" set="null" expr="4" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</PUSHDATA_CRC_COUNT>
		<FAST_HUFFMAN_LENGTH public="1" get="inline" set="null" expr="10" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</FAST_HUFFMAN_LENGTH>
		<FAST_HUFFMAN_TABLE_SIZE public="1" get="inline" set="null" expr="(1&lt;&lt;FAST_HUFFMAN_LENGTH)" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[(1<<FAST_HUFFMAN_LENGTH)]]></e></m></meta>
		</FAST_HUFFMAN_TABLE_SIZE>
		<FAST_HUFFMAN_TABLE_MASK public="1" get="inline" set="null" expr="FAST_HUFFMAN_TABLE_SIZE-1" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>FAST_HUFFMAN_TABLE_SIZE-1</e></m></meta>
		</FAST_HUFFMAN_TABLE_MASK>
		<haxe_doc>* ...
 * @author shohei909</haxe_doc>
	</class>
	<class path="stb.format.vorbis.flash.VorbisSound" params="" file="./src/stb/format/vorbis/flash/VorbisSound.hx">
		<implements path="flash.events.IEventDispatcher"/>
		<_rootReader><c path="stb.format.vorbis.Reader"/></_rootReader>
		<_us><c path="flash.net.URLStream"/></_us>
		<_ed><c path="flash.events.EventDispatcher"/></_ed>
		<length public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* sound playback length (Millisecond)</haxe_doc>
		</length>
		<url public="1" set="null">
			<c path="String"/>
			<haxe_doc>* loading URL. if loading from Bytes, value is null.</haxe_doc>
		</url>
		<play public="1" set="method" line="60">
			<f a="?startMillisecond:?loops:?sndTransform" v="0:0:">
				<x path="Float"/>
				<x path="Int"/>
				<c path="flash.media.SoundTransform"/>
				<c path="stb.format.vorbis.flash.VorbisSoundChannel"/>
			</f>
			<meta><m n=":value"><e>{loops:0,startMillisecond:0}</e></m></meta>
			<haxe_doc>* play sound.
	 * create VorbisSoundChannel instance.
	 * @param	startMillisecond  start play position. default is 0.
	 * @param	loops  loop count. default is 0. (no loop)
	 * @param	sndTransform  If you want to set volume, pan, etc... when creating instance, pass SoundTransform. default is null. 
	 * @return	VorbisSoundChannel	if don't have loaded data, return null.</haxe_doc>
		</play>
		<loadFromBytes public="1" set="method" line="87">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* load from already loaded OggVorbis bytes.
	 * If you use any other file loader. use this function.
	 * this function don't dispatch complete event.
	 * because It initialize at once.
	 * @param	bytes OggVorbis binary.</haxe_doc>
		</loadFromBytes>
		<load public="1" set="method" line="102">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* load from URL.
	 * dispatch event Event.COMPLETE when loading completed 
	 * 
	 * @param	url OggVorbis file URL.
	 * @eventType	Event.COMPLETE	loading completed.  
	 * @eventType	ProgressEvent.PROGRESS	loading processing.  
	 * @eventType	IOErrorEvent.IO_ERROR	loading failed.  
	 *    @throws	ArgumentError	url is null.</haxe_doc>
		</load>
		<close public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* close loading stream and dispose already loaded data.
	 * if you want to cancel when loading. use this function.</haxe_doc>
		</close>
		<onComplete set="method" line="131">
			<f a="e">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Loading complete handler.</haxe_doc>
		</onComplete>
		<onProgress set="method" line="143"><f a="e">
	<c path="flash.events.ProgressEvent"/>
	<x path="Void"/>
</f></onProgress>
		<onIOError set="method" line="144"><f a="e">
	<c path="flash.events.IOErrorEvent"/>
	<x path="Void"/>
</f></onIOError>
		<addEventListener public="1" set="method" line="148">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useWeakReference:false,priority:0,useCapture:false}</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method" line="153"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method" line="158"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method" line="163">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useCapture:false}</e></m></meta>
		</removeEventListener>
		<willTrigger public="1" set="method" line="168"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method" line="42">
			<f a="?url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	url(String) external OggVorbis file URL.  
	 * When pass the arguments, automaticaly start loading file.    
	 * it does not load when Void or null.</haxe_doc>
		</new>
		<haxe_doc>* VorbisSound can loading Vorbis file and create VorbisSoundChannel instance.
 * 
 * @author Tudurao Jin</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="stb.format.vorbis.flash.VorbisSoundChannel" params="" file="./src/stb/format/vorbis/flash/VorbisSoundChannel.hx">
		<implements path="flash.events.IEventDispatcher"/>
		<play public="1" set="method" line="104" static="1">
			<f a="sound:reader:startSample:loop:loopStartSample:loopEndSample:?soundTransform">
				<c path="flash.media.Sound"/>
				<c path="stb.format.vorbis.Reader"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.media.SoundTransform"/>
				<c path="stb.format.vorbis.flash.VorbisSoundChannel"/>
			</f>
			<haxe_doc>* play sound.
	 * this static function create new instance.
	 * @param	sound	use SampleDataEvent.SAMPLE_DATA event instanse.
	 * @param	reader	OggVorbis decoder.
	 * @param	startSample	start sample in Reader.
	 * @param	loop	Specified loop count.
	 * @param	loopStartSample	start position when loop.
	 * @param	loopEndSample
	 * @param	soundTransform</haxe_doc>
		</play>
		<channel public="1" set="null">
			<c path="flash.media.SoundChannel"/>
			<haxe_doc>* flash.media.SoundChannel instance.</haxe_doc>
		</channel>
		<leftPeak public="1" get="accessor" set="null"><x path="Float"/></leftPeak>
		<get_leftPeak set="method" line="25"><f a=""><x path="Float"/></f></get_leftPeak>
		<position public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* playing position (MilliSecond)</haxe_doc>
		</position>
		<get_position set="method" line="33"><f a=""><x path="Float"/></f></get_position>
		<rightPeak public="1" get="accessor" set="null"><x path="Float"/></rightPeak>
		<get_rightPeak set="method" line="39"><f a=""><x path="Float"/></f></get_rightPeak>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<haxe_doc>* SoundTransform. access to volume and pan.</haxe_doc>
		</soundTransform>
		<get_soundTransform set="method" line="47"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<set_soundTransform set="method" line="50"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<currentLoop public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* current loop count. value change to loop - 1 from 0.</haxe_doc>
		</currentLoop>
		<loop public="1">
			<x path="Int"/>
			<haxe_doc>* Specified loop count.</haxe_doc>
		</loop>
		<_reader>
			<c path="stb.format.vorbis.Reader"/>
			<haxe_doc>* OggVorbis decoder.</haxe_doc>
		</_reader>
		<_loopReader><c path="stb.format.vorbis.Reader"/></_loopReader>
		<_loopEnd><x path="Int"/></_loopEnd>
		<stop public="1" set="method" line="126">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* stop sound.</haxe_doc>
		</stop>
		<onSampleData set="method" line="135">
			<f a="event">
				<c path="flash.events.SampleDataEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>* SampleDataEvent handler.
	 * decoding data pass to sampling event.
	 * @param	event</haxe_doc>
		</onSampleData>
		<addEventListener public="1" set="method" line="163">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useWeakReference:false,priority:0,useCapture:false}</e></m></meta>
		</addEventListener>
		<removeEventListener public="1" set="method" line="168">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{useCapture:false}</e></m></meta>
		</removeEventListener>
		<dispatchEvent public="1" set="method" line="173"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method" line="178"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<willTrigger public="1" set="method" line="183"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new set="method" line="79">
			<f a="reader:startSample:loop:loopStartSample:loopEndSample">
				<c path="stb.format.vorbis.Reader"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* initialize.
	 * @param	reader
	 * @param	startSample
	 * @param	loop
	 * @param	loopStartSample
	 * @param	loopEndSample</haxe_doc>
		</new>
		<haxe_doc>* VorbisSoundChannel is control audio playback and SoundTransform.
 * instance create by VorbisSound.
 * 
 * @author Tudurao Jin</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
</haxe>